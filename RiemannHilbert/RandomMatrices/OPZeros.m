(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["RiemannHilbert`RandomMatrices`",{"RiemannHilbert`","RiemannHilbert`Common`"}];


FindZeros::usage="FindZeros[string,n] returns the scaled zeros, i.e. the zeros of the nth-order orthogonal polynomial for e^(-Q(x))dx with potential function Q(x)= V(x n^(1/(2m)) where m is the order of V(x).  The options for string are:
Quartic (V(x) = x^4), Eight (V(x) = x^8), Gaussian (V(x) = x^2), Sheehan(V(x) = x^2 + sin(x), untested), Cosh (V(x) = cosh(x), untested), and HODecay (untested)";
FindWeights::usage="FindWeights[string,n] returns the interpolation nodes and weights for the chosen potential.  See FindZeros for the choices for string.";
FindIterpolationWeights;
Begin["Private`"];


Module[{string},
string="HODecay";
EPotential[string][x_]:=x^2/5-4/15x^3+x^4/20+8/5 x;
EPotentialOrder[string][n_]:=4;
EPotentialUnscaled[string][N_][x_]:=EPotential[string][x N^(1/EPotentialOrder[string][N])]/N;
EDomain[string]=Line[{-4,6}];
EFunLength[string]=150;
ECoefParams[string]={1000,15,80};
EExpa[string]=2/3;
EExpb[string]=2/7;
EUP[string][n_]:=.8;
];
Module[{string},string="Quartic";
EPotential[string][x_]:=x^4;
EPotentialOrder[string][n_]:=4;
EPotentialUnscaled[string][N_][x_]:=EPotential[string][x N^(1/EPotentialOrder[string][N])]/N;
EDomain[string]=Line[{-3,3}];
EFunLength[string]=150;
ECoefParams[string]={1000,10,80};
EExpa[string]=2/3;
EExpb[string]=2/3;
EUP[string][n_]:=8;
];
Module[{string},string="Gaussian";
EPotential[string][x_]:=x^2;
EPotentialOrder[string][n_]:=2;
EPotentialUnscaled[string][N_][x_]:=EPotential[string][x N^(1/EPotentialOrder[string][N])]/N;
EDomain[string]=Line[{-3,3}];
EFunLength[string]=150;
ECoefParams[string]={1000,10,80};
EExpa[string]=2/3;
EExpb[string]=2/3;
EUP[string][n_]:=.8;
];
Module[{string},string="Eight";
EPotential[string][x_]:=x^8;
EPotentialOrder[string][n_]:=8;
EPotentialUnscaled[string][N_][x_]:=EPotential[string][x N^(1/EPotentialOrder[string][N])]/N;
EDomain[string]=Line[{-3,3}];
EFunLength[string]=150;
ECoefParams[string]={1000,10,80};
EExpa[string]=2/3;
EExpb[string]=2/3;
EUP[string][n_]:=.8;
];
Module[{string},string="Sheehan";
EPotential[string][x_]:=x^2+Sin[x];
EPotentialOrder[string][n_]:=2;
EPotentialUnscaled[string][N_][x_]:=EPotential[string][x N^(1/EPotentialOrder[string][N])]/N;
EDomain[string]=Line[{-4,4}];
EFunLength[string]=150;
ECoefParams[string]={1000,12,90};
EExpa[string]=2/3;
EExpb[string]=2/3;
EUP[string][n_]:=.5;
];
Module[{string},string="Singular";
EPotential[string][x_]:=x^2+Log[x^2+1];
EPotentialOrder[string][n_]:=2;
EPotentialUnscaled[string][N_][x_]:=EPotential[string][x N^(1/EPotentialOrder[string][N])]/N;
EDomain[string]=Line[{-4,4}];
EFunLength[string]=150;
ECoefParams[string]={1000,20,90};
EExpa[string]=2/3;
EExpb[string]=2/3;
EUP[string][n_]:=1/2 n^(-1/2);
];
Module[{string,c},string="Cosh";
EPotential[string][x_]:=Cosh[x];
EPotentialOrder[string][n_]:=If[n<=1,1,Log[n]/Log[c[n]]];
EPotentialUnscaled[string][N_][x_]:=EPotential[string][x N^(1/EPotentialOrder[string][N])]/N;
EDomain[string]=Line[{-4,4}];
EFunLength[string]=150;
ECoefParams[string]={1000,20,90};
EExpa[string]=2/3;
EExpb[string]=2/3;
EUP[string][n_]:=3/2 n^(-1/2);
c[1]=Fun[Function[c,(Cosh[c #]&//EquilibriumMeasureSupport//Last)-1],Line[{1.5,1.7}],10]//Roots//First;
c[n_]:=c[n]=Fun[Function[c,(1/n Cosh[c #]&//EquilibriumMeasureSupport//Last)-1],Line[{c[n-1],c[n-1]+.5}],10]//Roots//First;
];


RHP[string_,n_]:=Module[{numpts,intL,rhpts,V,out},
{numpts,intL,rhpts}=ECoefParams[string];(* some relevant RHP parameters *)
V[x_]:= EPotentialUnscaled[string][n][x]; (* Unscaled potential, coincides with the Scaled potential when it is a monomial *)
out=OrthogonalPolynomialMatrixGeneratorForRoots[EPotentialUnscaled[string][n],1,60,intL,2/3,2/3,1,EUP[string][n],{50,80}];
(*Quiet[Print[{Show[DCTPlot/@out[[5]][n]],Show[DCTPlot/@out[[6]][n]],Show[DCTPlot/@out[[7]][n]]}]];*)
out
(*DCT of the solution of the RHP andDCT of the solution evaluated on the real axis*)
];

iAf[a_,b_][z_]:=(z-(b-a)/2-a)/((b-a)/2);
IndefWeight[y_,k_]:=If[k==0,Pi-ArcCos[y],-1/k Sin[k ArcCos[y]]];
IndefInt[coef_,y_]:=Module[{k},
Sum[IndefWeight[y,k-1]*coef[[k]],{k,1,Length[coef]}]
];
IndefInt[f_,y_,a_,b_]:=IndefInt[f,iAf[a,b][y]];

GenerateGuessHO//Clear;
GenerateGuessHO[string_,n_]:=GenerateGuessHO[string,n]=Module[{V,numguess,f,\[Phi],aa,bb,z,ans,temp,p,coef,df,zn,ii},
numguess=n;
V[x_]:= EPotentialUnscaled[string][n][x];
(*find the EM with Sheehan's code*)
\[Phi]=EquilibriumMeasure[V];
{aa,bb}=EquilibriumMeasureSupport[V];
ans=N[Table[i/(numguess+1),{i,1,numguess}]]; (*uniformly on [0,1], we then find zn[i] so that Integrate[\[Phi][x],{x,aa,zn[i]}] = ans[[i]] with a Newton iteration *)
temp=Fun[\[Phi]//Values,Line[{aa,bb}]];
p=Fun[temp[#//Chop](bb-#)(#-aa)*2/(bb-aa)&,Line[{aa,bb}],Length[temp]+2];
coef=p//DCT;
f[x_]:=f[x]=\[Piecewise]{
 {IndefInt[coef,x,aa,bb], aa<x<bb},
 {0., x<=aa},
 {1., x>=bb}
};
df[x_]:=df[x]=\[Piecewise]{
 {\[Phi][x], aa<x<bb},
 {0., x<=aa},
 {1., x>=bb}
};


z//Clear;
z[0]=Table[i/(numguess),{i,1,numguess-1}](bb-aa)-bb;
ans=Table[i/(numguess),{i,1,numguess-1}];
z[nn_]:=z[nn]=z[nn-1]-((f/@z[nn-1])-ans)/(df/@z[nn-1]);
For[ii=1,ii<=50,ii++,
(*Max[Abs[z[ii]-z[ii-1]]]//Print;*)
If[Max[Abs[z[ii]-z[ii-1]]]<10^(-14),Break[]];
];
z[ii]=(2Join[z[ii],{bb}]-(bb+aa))/(bb-aa);


ans=Table[(6i-3)/(6numguess)+1/(2Pi numguess) ArcSin[-z[ii][[i]]],{i,1,numguess}];
zn//Clear;
zn[0]=Table[i/(numguess+1),{i,1,numguess}](bb-aa)-bb;
zn[nn_]:=zn[nn]=zn[nn-1]-((f/@zn[nn-1])-ans)/(df/@zn[nn-1]);
For[ii=1,ii<=50,ii++,
(*Max[Abs[zn[ii]-zn[ii-1]]]//Print;*)
If[Max[Abs[zn[ii]-zn[ii-1]]]<10^(-14),Break[]];
];
zn[ii]

];
SetupOPs//Clear;
SetupOPs[string_,n_]:=SetupOPs[string,n]=Module[{out,P,DP,V,M,DM,Mm,ln},
out = RHP[string,n];
P//Clear;DP//Clear;
V=EPotentialUnscaled[string][n];
P[x_]:=P[x]=out[[1]][n,x][[1]]Exp[-n V[x]/2]//Re;
DP[x_]:=DP[x]=(out[[2]][n,x][[1]]Exp[-n V[x]/2]-n/2V'[x]out[[1]][n,x][[1]]Exp[-n V[x]/2])//Re;
M//Clear;DM//Clear;Mm//Clear;
M[x_]:=M[x]=out[[1]][n,x][[1]]//Re;
DM[x_]:=DM[x]=out[[2]][n,x][[1]]//Re;
Mm[x_]:=Mm[x]=out[[3]][n,x][[1]]//Im;
ln=out[[-1]][n];
{P,DP,DM,Mm}
];
GetZeros[zn_,data_]:=Module[{x,numguess,i,tol,zeros,iter,newzeros,sumiter},
numguess=zn//Length;
For[i=1,i<=numguess,i++,
x[0,i]=zn[[i]];
];
x[n_,i_]:=x[n,i]=x[n-1,i]-data[[1]][x[n-1,i]]/data[[2]][x[n-1,i]]/.Indeterminate->1./.\[Infinity]->1./.ComplexInfinity->1.;
tol=10^(-14)/2;
sumiter=0;
zeros=ConstantArray[0.,numguess];
For[i=1,i<=numguess,i++,
For[iter=1,iter<=20,iter++,
If[Abs[x[iter,i]-x[iter-1,i]]< tol,
zeros[[i]]=x[iter,i];
(*sumiter=sumiter+iter;*)
Break[];
];
];
];
(*Print["Avg Iteration #: "<>ToString[sumiter/numguess//N]];*)
newzeros={zeros[[1]]};
For[i=2,i<=numguess,i++,
If[Abs[newzeros[[-1]]-zeros[[i]]]> 10^(-10),newzeros=newzeros~Join~{zeros[[i]]}];
];
newzeros
];
FindZeros//Clear;(*find scaled zeros, sit inside the support of the EM*)
FindZeros[string_,n_]:=FindZeros[string,n]=Module[{data},
data=SetupOPs[string,n];
GetZeros[GenerateGuessHO[string,n],data]
];

FindWeights//Clear;FindInterpolationWeights//Clear;
FindWeights[string_,n_]:=FindWeights[string,n]=Module[{z,data},
z=FindZeros[string,n];
data=SetupOPs[string,n];
Table[{z[[i]]n^(1/EPotentialOrder[string][n]),-2Pi n^(1/EPotentialOrder[string][n])/(data[[3]][z[[i]]]data[[4]][z[[i]]])},{i,1,Length[z]}]
];
FindInterpolationWeights[string_,n_]:=FindInterpolationWeights[string,n]=Module[{z,data},
z=FindZeros[string,n];
data=SetupOPs[string,n];
Table[{z[[i]]n^(1/EPotentialOrder[string][n]),-2Pi n^(2/EPotentialOrder[string][n])/(data[[3]][z[[i]]])},{i,1,Length[z]}]
];
Barycentric[f_,\[Lambda]_,string_][z_]:=Sum[f[[i]]\[Lambda][[i,2]]/(z-\[Lambda][[i,1]]),{i,1,Length[f]}]/Sum[\[Lambda][[i,2]]/(z-\[Lambda][[i,1]]),{i,1,Length[f]}];
BarycentricOne[\[Pi]_,f_,\[Lambda]_,string_][z_]:=Sum[\[Pi][z] f[[i]]\[Lambda][[i,2]]/(z-\[Lambda][[i,1]]),{i,1,Length[f]}];
Interpolate[f_,string_,n_]:=Module[{},
interpolationweights=FindInterpolationWeights[string,n];
Barycentric[f[interpolationweights[[All,1]]],interpolationweights//Re,string]
];


End[];
EndPackage[];
