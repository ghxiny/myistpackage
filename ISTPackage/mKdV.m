(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["RiemannHilbert`"];
HillmKdV::usage="HillmKdV[q,n] gives the eigenvalues of the modified Zakharov-Shabat scattering (including continuous spectrum) problem with n Fourier modes using Hill's method.";
LocatePolesmKdV::usage="LocatePoles[q,n] gives the true eigenvalues of the modified Zakharov-Shabat scattering problem.";
mKdV::usage="mKdV[i][x,t] = {out,\[CapitalPhi],rhp1,rhp2,timestring} where out is the solution of mKdV, \[CapitalPhi] is the solution of the Riemann-Hilbert problem, rhp1 and rhp2 are the Riemann-Hilbert problems and timestring is the string of computation times.  This is done using the deformation in Region i.";
mKdVAuto::usage="mKdVAuto[x,t] returns the solution of the mKdV equation with deformation selected automagically.  Many things must be initialized.  Sample code:

	q[x_]:=.1 Exp[-x^2+I x];
Defocusing[];
	H=ScatteringMatrixFinitemKdV[q,50,6];
aa//Clear;bb//Clear;
aa[k_]:=aa[k]=H[k][[1,1]];
bb[k_]:=bb[k]=H[k][[2,1]];
	SetParams[.6,.1,10.^(-9),15,30];
h[k_]:=3/(1+Abs[k/2+1/3.2]^8);
Setrsamp[h];
Settimeflag[False];
\[Nu]=Getnu[];
\[Rho][k_]:=bb[k]/aa[k];
	up=I(\[Nu]+.0001);m=40;el=8;
f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};

	up=I(\[Nu]+.0001);m=40;el=8;
f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};
SetScatteringData[aa,bb,m\[Rho],LocatePoles[q,40]]"
Focusing::usage="Focusing[], switch to focusing mKdV";
Defocusing::usage="Defocusing[], switch to focusing mKdV";
SetScatteringData::usage="SetScatteringData[a,b,\[Rho],poles] or SetScatteringData[a,b,\[Rho],poles,normingConstants] sets the scattering data for the mKdV equation";
SetParams::usage="SetParams[\[Nu],rad,globalTol,smallN,bigN] sets the parameters for the rest of the code:
	\[Nu]: half of width of strip of analyticity
	rad: radius of soliton contours
	globalTol: contour truncation tolerance
	smallN: small number of collocation points
	bigN: big number of collocation points";
GetScatteringData::usage="GetScatteringData[] = {\[Rho],poles,normingConstants}";
ScatteringMatrixFinitemKdV::usage="ScatteringMatrixFinitemKdV[q,n,L] returns a function f[w] that produces an approximation of the scattering matrix at w. The parameter n indicates the number of collocation points and L sets the problem on [-L,L]
Sample code:
	q[x_]:=.1 Exp[-x^2+I x];
Defocusing[];
	H=ScatteringMatrixFinitemKdV[q,50,6];
aa//Clear;bb//Clear;
aa[k_]:=aa[k]=H[k][[1,1]];
bb[k_]:=bb[k]=H[k][[2,1]];
";
Getnu::usage="Getnu[] returns \[Nu]";
Setrsamp::usage="Setrsamp[h] sets a function that should be chosen so that that |\[Rho]| < h";
timestring::usage="A string updated by mKdV[i][x,t]
(x,t) 1) Construct: --time to construct rhp1-- 1) Solve: --time to solve rhp1-- 2) Construct: --time to construct rhp2-- 2) Solve: --time to solve rhp2--";
Settimeflag::usage="Settimeflag[bool] bool = True forces timestring to be printed each time mKdV[i][x,t] is called";
startift;
domainOutput;
ift;
\[CapitalPhi]t;
\[CapitalPhi]tin;
dom;
J;
Jadapt;
L;U;

Begin["Private`"];


Focusing[]:=Module[{},\[Lambda]=1];
Defocusing[]:=Module[{},\[Lambda]=-1];
SetScatteringData[aa_,bb_,rr_,ma_,mc_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],100}][[1]];
c=mc;
];
SetScatteringData[aa_,bb_,rr_,ma_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
If[ma!= {},
(*Print[Fun[h[#]&,Line[{-1,1}],10]];*)
dom=Truncate[globalTol][{h[#]&,Line[{-el,el}],100}][[1]];
f1 = Fun[aa[#]&,dom,100];
df1=f1';
da[k_]:=Cauchy[df1,k];
c={};
For[i=1,i<=Length[ma],i++,
c=Join[c,{Quiet[bb[ma[[i]]]]/da[ma[[i]]]}];(*compute norming constants*)
];
];
];
SetParams[nu_,rad1_,tol_,sN_,bN_]:=Module[{},
\[Nu]=nu; (*parameter for width of strip of analyticity*)
rad=rad1;
globalTol=tol;
smallN=sN;
bigN=bN;
];
GetScatteringData[]:=Module[{},{r,a,c}];
Getnu[]:=\[Nu];
Setrsamp[h_]:=Module[{},rsamp=h];
Settimeflag[h_]:=Module[{},timeflag=h];
SetN[x_]:=Module[{},bigN=x[[1]];smallN=x[[2]];];
expconst=1;
el=1000;
bigN=20;
smallN=10;


CME[x_]:=Chop[x,$MachineEpsilon];
ScatteringMatrixFinitemKdV[q_,n_,el_]:=Module[{qf,qfb,Dm,Dmb,IIm,IImb,P,Pb,id,Q,R,Qb,Rb,DM,DMb,q\[Sigma]1,q\[Sigma]1b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,rhs,A,Ab},
 qf=Fun[q,Line[{-el,0}],n];
qfb=Fun[q,Line[{0,el}],n];
Print[{qf//Values//First//Abs,qf//DCTPlot}];
Dm=DerivativeMatrix[qf];
Dmb=DerivativeMatrix[qfb];
IIm=ReduceDimensionIntegrateMatrix[qf];
IImb=(ReduceDimensionIntegrateMatrix[(qfb//ReverseOrientation)]//Transpose//Reverse//Transpose//Reverse);
id=IdentityMatrix[n];
Q = DiagonalMatrix[qf//Values];
R= -\[Lambda] DiagonalMatrix[qf//Values];
Qb = DiagonalMatrix[qfb//Values];
Rb = -\[Lambda] DiagonalMatrix[qfb//Values];
A=BlockMatrix[{{id,-IIm.Q},{-IIm.R,id}}];
Ab=BlockMatrix[{{id,-IImb.Qb},{-IImb.Rb,id}}];
J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
ScatteringMatrixFinitemKdV[qf,qfb,A,Ab,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,IIm,IImb]];
ScatteringMatrixFinitemKdV[qf_,qfb_,A_,Ab_,J\[Sigma]3_,J\[Sigma]31_,J\[Sigma]3b_,J\[Sigma]31b_,IIm_,IImb_][w_]:=Module[{ans0,ans1,rhs,lhs,n,s1,s2,qb,q,r,rb},
q = qf//Values;
qb = qfb//Values;
r = -\[Lambda] q//Conjugate;
rb= -\[Lambda] qb//Conjugate;
n = q//Length;
lhs=A+ w*J\[Sigma]3;
rhs = Join[ConstantArray[0.,n],IIm.r];
ans0 = LinearSolve[lhs//CME,rhs//CME];
lhs=A+w*J\[Sigma]31;
rhs=Join[IIm.q,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
s1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};
lhs=Ab+ w*J\[Sigma]3b;
Off[LinearSolve::luc];
rhs = Join[ConstantArray[0.,n],IImb.rb];
ans0 = LinearSolve[lhs//CME,rhs//CME];
lhs=Ab+ w*J\[Sigma]31b;
rhs = Join[IImb.qb,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
On[LinearSolve::luc];
s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};
s1=Inverse[s2].s1
];


HillmKdV[F_,n_]:=Module[{c2,c1,c0,f11,f12,zz,f02,f01,t,A,mu,L,P,fun},
mu = .25;
L = Pi;
P =1;
f11[x_]:= 2I Cos[x/2]^2;
f12[x_]:=-2I Cos[x/2]^2;
zz[x_]:=ConstantArray[0.,Length[x]];
t[x_] := Tan[x/2];
f02[x_]:= -I F[t[x]];
f01[x_]:=-\[Lambda] I F[t[x]];
fun= {{{zz,f11},{f02,zz}},{{f01,zz},{zz,f12}}};
A= Hill[mu,L,n,P,fun];
Eigenvalues[Chop[A,$MachineEpsilon]]
];
LocatePolesmKdV[F_,n_]:=Module[{eval,s,i,sys,vecs},
Off[General::unfl];
eval=HillmKdV[F,n];
s = {};
For[i=1,i<=Length[eval],i++,
If[Im[eval[[i]]]>10^(-4)&& Abs[eval[[i]]]<30,
s=Join[s,{eval[[i]]}];
];
];
On[General::unfl];
Chop[s,$MachineEpsilon]
];


\[Theta][x_,t_][z_]:=2 I (4 t z^3+x z);
rb[k_]:=\[Lambda] cc[r[cc[k]]];
rbsamp[k_]:=\[Lambda] cc[rsamp[cc[k]]];
\[Tau]samp[k_]:=1+\[Lambda] rsamp[k]cc[rsamp[cc[k]]];

L[x_,t_][k_]:=({
 {1, 0},
 {r[k]/\[Tau][k] Exp[\[Theta][x,t][k]], 1}
});
Lsamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k]/\[Tau]samp[k] Exp[\[Theta][x,t][k]], 1}
});

Lin[x_,t_][k_]:=({
 {1, 0},
 {-(r[k]/\[Tau][k])Exp[\[Theta][x,t][k]], 1}
});
Linsamp[x_,t_][k_]:=({
 {1, 0},
 {-(rsamp[k]/\[Tau]samp[k])Exp[\[Theta][x,t][k]], 1}
});


U[x_,t_][k_]:=({
 {1, rb[k]/\[Tau][k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Uin[x_,t_][k_]:=({
 {1, -(rb[k]/\[Tau][k])Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Usamp[x_,t_][k_]:=({
 {1, rbsamp[k]/\[Tau]samp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Uinsamp[x_,t_][k_]:=({
 {1, -(rbsamp[k]/\[Tau]samp[k])Exp[-\[Theta][x,t][k]]},
 {0, 1}
});

DD[x_,t_][k_]:=({
 {\[Tau][k], 0},
 {0, 1/\[Tau][k]}
});
DDin[x_,t_][k_]:=({
 {1/\[Tau][k], 0},
 {0, \[Tau][k]}
});

DDsamp[x_,t_][k_]:=({
 {\[Tau]samp[k], 0},
 {0, 1/\[Tau]samp[k]}
});
DDinsamp[x_,t_][k_]:=({
 {1/\[Tau]samp[k], 0},
 {0, \[Tau]samp[k]}
});

G[x_,t_][z_]:=({
 {1+r[z]rb[z], rb[z]Exp[-2 I (4 t z^3+x z)]},
 {r[z] Exp[2 I (4t z^3+ x z)], 1}
});
G[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
Gsamp[x_,t_][z_]:=({
 {1+rsamp[z]rbsamp[z], rbsamp[z]Exp[-2 I (2 t z^2+x z)]},
 {rsamp[z] Exp[2 I (2 t z^2+ x z)], 1}
});
Gsamp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
M[x_,t_][k_]:=({
 {1, rb[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Msamp[x_,t_][k_]:=({
 {1, rbsamp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Minv[x_,t_][k_]:=({
 {1, -rb[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Minvsamp[x_,t_][k_]:=({
 {1, -rbsamp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
P[x_,t_][k_]:=({
 {1, 0},
 {r[k] Exp[\[Theta][x,t][k]], 1}
});
Psamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k] Exp[\[Theta][x,t][k]], 1}
});


qq[x_,t_][k_]:=Module[{out,i},
out = 1;
For[i=1,i<=Length[a],i++,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
out = out*(k-a[[i]])/(k-Conjugate[a[[i]]]);
];
];
out];
Q[x_,t_][k_]:=({
 {qq[x,t][k], 0},
 {0, 1/qq[x,t][k]}
});
Q[x_,t_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
startift[]:=Module[{},
Clear[ift];
ift[k0_]:=ift[k0]=Fun[Log[\[Tau][#]]&,{-Min[k0,el],Min[k0,el]}//Line,100];
];
startift[];
\[Delta]t[x_,t_][s_,k_]:=(Cauchy[s,ift[Abs[K0[x,t]]],k]//Exp);
\[Delta]t[x_,t_][k_]:=(Cauchy[ift[Abs[K0[x,t]]],k]//Exp);
\[CapitalPhi]t[x_,t_][z__]:=({
 {\[Delta]t[x,t][z], 0},
 {0, 1/\[Delta]t[x,t][z]}
});
\[CapitalPhi]tin[x_,t_][z__]:=({
 {1/\[Delta]t[x,t][z], 0},
 {0, \[Delta]t[x,t][z]}
});
K0[x_,t_]:=Sqrt[-x/(12 t)];
K0[_,t_?ZeroQ]:=\[Infinity];


J[0][x_,t_]:={{G[x,t][#]&,G[x,t][#]&},{Line[{-el,0}],Line[{0,el}]},{2*bigN,2*bigN}};
Jsamp[0][x_,t_]:={{Gsamp[x,t][#]&,Gsamp[x,t][#]&},{Line[{-el,0}],Line[{0,el}]},{2*bigN,2*bigN}};
Jadapt[0][x_,t_]:=Adapt[Jsamp[0][x,t],globalTol][J[0][x,t]]


c1[x_,t_]:=If[\[Nu]-Abs[K0[x,t]]>0 && x >= 0,
{Line[{-el+I \[Nu],Sqrt[2]Exp[3I Pi/4](\[Nu]-Abs[K0[x,t]]) + I Abs[K0[x,t]]}],
Line[{Sqrt[2]Exp[3I Pi/4]Abs[\[Nu]-Abs[K0[x,t]]] + I Abs[K0[x,t]],I Abs[K0[x,t]]}],
Line[{I Abs[K0[x,t]],Sqrt[2]Exp[I Pi/4]Abs[\[Nu]-Abs[K0[x,t]]] + I Abs[K0[x,t]]}],Line[{Sqrt[2]Exp[I Pi/4]Abs[\[Nu]-Abs[K0[x,t]]] + I Abs[K0[x,t]],el+I \[Nu]}]},
{Line[{-el+I \[Nu],I \[Nu]}],Line[{I \[Nu],I \[Nu] + el}]}
];
J[1][x_,t_]:=If[Abs[K0[x,t]]<\[Infinity],{Join[Table[P[x,t][#]&,{i,1,Length[c1[x,t]]}],Table[M[x,t][#]&,{i,1,Length[c1[x,t]]}]],
Join[c1[x,t],c1[x,t]//LineConjugate],
Table[bigN,{i,1,2*Length[c1[x,t]]}]},
{{P[x,t][#]&,P[x,t][#]&,M[x,t][#]&,M[x,t][#]&},{Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]},{bigN,bigN,bigN,bigN}}
];


Jsamp[1][x_,t_]:=
If[Abs[K0[x,t]]<\[Infinity],{Join[Table[Psamp[x,t][#]&,{i,1,Length[c1[x,t]]}],Table[Msamp[x,t][#]&,{i,1,Length[c1[x,t]]}]],
Join[c1[x,t],c1[x,t]//LineConjugate],
Table[bigN,{i,1,2*Length[c1[x,t]]}]},
{{Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&},{Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]},{bigN,bigN,bigN,bigN}}
];
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]]


c2[x_,t_]:={
Line[{-el+I \[Nu],Sqrt[2]Exp[3Pi/4I]\[Nu]-Abs[K0[x,t]]}],Line[{Sqrt[2]Exp[3Pi/4I]\[Nu]-Abs[K0[x,t]],-Abs[K0[x,t]]}],
Line[{-Abs[K0[x,t]],Abs[K0[x,t]]}],
Line[{Abs[K0[x,t]],Sqrt[2]Exp[1Pi/4I]\[Nu]+Abs[K0[x,t]]}],
Line[{Sqrt[2]Exp[1Pi/4I]\[Nu]+Abs[K0[x,t]],I \[Nu] + el}],
Line[{-el-I \[Nu],Sqrt[2]Exp[5Pi/4I]\[Nu]-Abs[K0[x,t]]}],Line[{Sqrt[2]Exp[5Pi/4I]\[Nu]-Abs[K0[x,t]],-Abs[K0[x,t]]}],Line[{Abs[K0[x,t]],Sqrt[2]Exp[-1Pi/4I]\[Nu]+Abs[K0[x,t]]}],
Line[{Sqrt[2]Exp[-1Pi/4I]\[Nu]+Abs[K0[x,t]],-I \[Nu] + el}]
};
J[2.5][x_,t_]:={{P[x,t][#]&,P[x,t][#]&,G[x,t][#]&,P[x,t][#]&,P[x,t][#]&,M[x,t][#]&,M[x,t][#]&,M[x,t][#]&,M[x,t][#]&},
c2[x,t],
Table[2 smallN,{i,1,Length[c2[x,t]]}]};
Jsamp[2.5][x_,t_]:={{Psamp[x,t][#]&,Psamp[x,t][#]&,Gsamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&},
c2[x,t],
Table[2 smallN,{i,1,Length[c2[x,t]]}]};
Jadapt[2.5][x_,t_]:=Adapt[Jsamp[2.5][x,t],globalTol][J[2.5][x,t]]


(*Valid for |K0| > \[Nu]*)
if[t_]:=.25/(1+Sqrt[t]);
rays[x_,t_]:= {Line[{Exp[I 3 Pi /4],if[t] Exp[I 3 Pi /4]}],Line[{Exp[I 5Pi /4],if[t] Exp[I 5 Pi /4]}],Line[{if[t] Exp[-I Pi /4], Exp[-I Pi /4]}],Line[{if[t] Exp[I Pi /4],Exp[I Pi /4]}]}*\[Nu];
square[x_,t_]:={Line[{Exp[I 3 Pi /4],Exp[I 5 Pi /4]}],Line[{Exp[I 5 Pi /4],Exp[I 7Pi /4]}],Line[{Exp[I 7 Pi /4],Exp[I Pi /4]}],Line[{Exp[I Pi /4],Exp[I 3Pi /4]}]}*if[t] \[Nu];
stencil[x_,t_]:= Join[rays[x,t],square[x,t]]*Sqrt[2];
extendL = {Line[{-el + I \[Nu],Sqrt[2]Exp[3 Pi/4I] \[Nu]}],
Line[{-el - I \[Nu],Sqrt[2]Exp[5Pi/4I] \[Nu]}]};
extendR= {Line[{Sqrt[2]Exp[Pi/4I] \[Nu], el + I \[Nu]}],
Line[{Sqrt[2]Exp[-Pi/4I] \[Nu],el- I \[Nu]}]};
connect[x_,t_]:= {Line[{-Abs[K0[x,t]] + Sqrt[2]\[Nu] Exp[I Pi/4],Abs[K0[x,t]] + Sqrt[2]\[Nu] Exp[3I Pi/4]}],Line[{-Abs[K0[x,t]] + Sqrt[2]\[Nu] Exp[-I Pi/4],Abs[K0[x,t]] + Sqrt[2]\[Nu] Exp[-3I Pi/4]}]};
ctr[x_,t_]:=Join[extendL-K0[x,t],stencil[x,t] - K0[x,t],connect[x,t],stencil[x,t]+K0[x,t],extendR + K0[x,t]];
DDI[x_,t_][k_]:=If[Im[k] >=0,DD[x,t][k],IdentityMatrix[2]];
DDIin[x_,t_][k_]:=If[Im[k] >=0,DDin[x,t][k],IdentityMatrix[2]];
DDIsamp[x_,t_][k_]:=If[Im[k] >=0,DDsamp[x,t][k],IdentityMatrix[2]];
DDIinsamp[x_,t_][k_]:=If[Im[k] >=0,DDinsamp[x,t][k],IdentityMatrix[2]];
J[3.3][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]t[x,t][#].U[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].U[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#].\[CapitalPhi]tin[x,t][#]&};Domains={Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]};
NumPts={bigN,bigN,bigN,bigN};
{Jumps,Domains,NumPts}
];
Jsamp[3.3][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Usamp[x,t][#]&,
Usamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&
};
Domains={Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]};
NumPts={bigN,bigN,bigN,bigN};
{Jumps,Domains,NumPts}
];


J[3.2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&,(*end extendL*)
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].U[x,t][#].\[CapitalPhi]tin[x,t][#]&,(*end rays L*)
\[CapitalPhi]t[x,t][#].Minv[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].DDIin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Uin[x,t][#].DDin[x,t][#]&,(*end square L*)
\[CapitalPhi]t[x,t][#].U[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#].\[CapitalPhi]tin[x,t][#]&, (*end connect*)
\[CapitalPhi]t[x,t][#].U[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,(*end rays R*)
\[CapitalPhi]t[x,t][#].DDIin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].Minv[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].Uin[x,t][#].DDin[x,t][#]&,(*end square L*)
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&(*end extendR*)
};
Domains = ctr[x,t];
NumPts = Table[smallN,{i,1,Length[Domains]}];
{Jumps,Domains,NumPts}
];
Jsamp[3.2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Psamp[x,t][#]&,
Msamp[x,t][#]&,(*end extendL*)
Psamp[x,t][#]&,
Msamp[x,t][#]&,
Lsamp[x,t][#]&,
Usamp[x,t][#]&,(*end rays L*)
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,(*end square L*)
Usamp[x,t][#]&,
Lsamp[x,t][#]&, (*end connect*)
Usamp[x,t][#]&,
Lsamp[x,t][#]&,
Msamp[x,t][#]&,
Psamp[x,t][#]&,(*end rays R*)
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,(*end square L*)
Psamp[x,t][#]&,
Msamp[x,t][#]&(*end extendR*)
};
Domains = ctr[x,t];
NumPts = Table[smallN,{i,1,Length[Domains]}];
{Jumps,Domains,NumPts}
];
Jadapt[3.2][x_,t_]:=Adapt[Jsamp[3.2][x,t],globalTol][J[3.2][x,t]];


(*Valid if |K0|< \[Nu]*)
skewrays[x_,t_]:= {Line[{Exp[I 3 Pi /4],if[t] Exp[I 3 Pi /4]}],Line[{Exp[I 5Pi /4],if[t] Exp[I 5 Pi /4]}],Line[{if[t] Exp[-I Pi /4],Abs[K0[x,t]]/\[Nu] Exp[-I Pi /4]}],Line[{if[t] Exp[I Pi /4],Abs[K0[x,t]]/\[Nu] Exp[I Pi /4]}]}*\[Nu];
stencilskewL[x_,t_]:= Join[skewrays[x,t],square[x,t]]*Sqrt[2];
stencilskewR[x_,t_]:= Join[-skewrays[x,t]//LineReverse,square[x,t]]*Sqrt[2];
ctrskew[x_,t_]:=Join[extendL-K0[x,t],stencilskewL[x,t] - K0[x,t],stencilskewR[x,t]+K0[x,t],extendR + K0[x,t]];
J[3.1][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&,(*end extendL*)
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].U[x,t][#].\[CapitalPhi]tin[x,t][#]&,(*end rays L*)
\[CapitalPhi]t[x,t][#].Minv[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].DDIin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Uin[x,t][#].DDin[x,t][#]&,(*end square L*)
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].U[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#].\[CapitalPhi]tin[x,t][#]&,(*end rays R with rotation*)
\[CapitalPhi]t[x,t][#].DDIin[x,t][#]&,
\[CapitalPhi]t[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].Minv[x,t][#].L[x,t][#]&,
\[CapitalPhi]t[x,t][#].Uin[x,t][#].DDin[x,t][#]&,(*end square R*)
\[CapitalPhi]t[x,t][#].P[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].M[x,t][#].\[CapitalPhi]tin[x,t][#]&(*end extendR*)
};
Domains = ctrskew[x,t];
NumPts = Table[smallN,{i,1,Length[Domains]}];
{Jumps,Domains,NumPts}
];
Jsamp[3.1][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Psamp[x,t][#]&,
Msamp[x,t][#]&,(*end extendL*)
Psamp[x,t][#]&,
Msamp[x,t][#]&,
Lsamp[x,t][#]&,
Usamp[x,t][#]&,(*end rays L*)
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,(*end square L*)
Msamp[x,t][#]&,
Psamp[x,t][#]&,
Usamp[x,t][#]&,
Lsamp[x,t][#]&,(*end rays R*)
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,(*end square L*)
Psamp[x,t][#]&,
Msamp[x,t][#]&(*end extendR*)
};
Domains = ctrskew[x,t];
NumPts = Table[smallN,{i,1,Length[Domains]}];
{Jumps,Domains,NumPts}
];
Jadapt[3.1][x_,t_]:=Adapt[Jsamp[3.1][x,t],globalTol][J[3.1][x,t]];

J[3][x_,t_]:=\[Piecewise]{
 {J[3.2][x,t], el>Abs[K0[x,t]]>\[Nu]},
 {J[3.1][x,t], Abs[K0[x,t]]<=\[Nu]},
 {J[3.3][x,t], True}
};
Jsamp[3][x_,t_]:=\[Piecewise]{
 {Jsamp[3.2][x,t], el>Abs[K0[x,t]]>\[Nu]},
 {Jsamp[3.1][x,t], Abs[K0[x,t]]<=\[Nu]},
 {Jsamp[3.3][x,t], True}
};
Jadapt[3][x_,t_]:=Adapt[Jsamp[3][x,t],globalTol][J[3][x,t]];



T[+1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {-c Exp[\[Theta][x,t][a]]/(z-a), 1}
});
T[-1][x_,t_,a_,c_][z_]:=({
 {1, \[Lambda] cc[-c Exp[\[Theta][x,t][a]]/(cc[z]-a)]},
 { 0, 1}
});
S[+1][x_,t_,a_,c_][z_]:=({
 {1, -(z-a)/c*Exp[-\[Theta][x,t][a]]},
 {0, 1}
});
S[-1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {\[Lambda] cc[-(cc[z]-a)/c*Exp[-\[Theta][x,t][a]]], 1}
});
ContourArray[+1,r_,a_]:={Arc[a,r,{0,Pi}],Arc[a,r,{Pi,2Pi}]};
ContourArray[-1,r_,a_]:={Arc[a//cc,r,{0,-Pi}],Arc[a//cc,r,{-Pi,-2Pi}]};


PoleList[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
If[1/globalTol>Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]&&Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> globalTol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{S[+1][x,t,a[[i]],c[[i]]],S[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{S[-1][x,t,a[[i]],c[[i]]],S[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{T[+1][x,t,a[[i]],c[[i]]],T[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{T[-1][x,t,a[[i]],c[[i]]],T[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArray[+1,rad,a[[i]]],ContourArray[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];


DomainIntegrate[0.]:=0;
DomainIntegrate[{{0.,0.},{0.,0}}]:={{0.,0.},{0.,0}};
tcrit=8;
mKdV[i_][x_,t_]:=Module[{rhp1,rhp2,scale,\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi],out,t1,t2,t3,t4,poles,pl},
RHSolved//Clear;
RHSolved[X_]:=RHSolved[X]=RHSolve[X];
RHSolved[{}]:={{0.,0.},{0.,0}};
RHSolution[X_][z_]:=Cauchy[X//RHSolved,z]+IdentityMatrix[2];
Cauchy[{{0.,0.},{0.,0.}}][k_]:={{0.,0.},{0.,0.}};

t1=AbsoluteTiming[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]//MakeListFun;];
t2=AbsoluteTiming[RHSolved[rhp1];];
\[CapitalPhi]1[z_]:=RHSolution[rhp1][z]//Inverse;


pl=PoleList[x,t];
If[pl=={},
rhp2={};
t3={0};,
rhp2= ConjugateList[pl,Q[x,t]];
If[i==3,
rhp2= ConjugateList[rhp2,\[CapitalPhi]tin[x,t]];
];
t3=Timing[rhp2= ConjugateList[rhp2,\[CapitalPhi]1]//MakeListFun;];
];
t4=Timing[RHSolved[rhp2];];
\[CapitalPhi]2 = RHSolution[rhp2];
\[CapitalPhi][k_]:=RHSolution[rhp2][k].RHSolution[rhp1][k];
out=-(DomainIntegrate[RHSolved[rhp1]]+DomainIntegrate[RHSolved[rhp2]])[[1,2]]/Pi;
domainOutput = DomainPlot[Join[rhp1,rhp2]]//Quiet;
timestring= "Region: " <>ToString[i]<>" ("<>ToString[x]<>","<>ToString[t]<>") "<>"1) Construct: " <> ToString[t1//First]<>"  "<>"1) Solve: " <> ToString[t2//First]<>"  "<>"2) Construct: " <> ToString[t3//First]<>"  "<>"2) Solve: " <> ToString[t4//First];
If[timeflag,Print[timestring];];
{out,\[CapitalPhi],rhp1,rhp2,timestring}
];
mKdVAuto[x_,t_]:=\[Piecewise]{
 {mKdV[0][x,t][[1]], Abs[x]<=3&&t<.1},
 {mKdV[1][x,t][[1]], x >=0},
 {mKdV[2.5][x,t][[1]], x <0 && Abs[x]<=3t^(1/3)},
 {mKdV[3][x,t][[1]], x<0 && Abs[x]>3t^(1/3)}
}



End[];
