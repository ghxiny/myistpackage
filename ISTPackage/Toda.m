(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["RiemannHilbert`"];
SetScatteringData;
SetParams;
GetScatteringData;
ScatteringMatrixFiniteToda;
ScatteringMatrixFiniteTodaC;
LocatePolesToda;
ResiduesToda;
(*CircleRHP;
CircleRHPsamp;
\[CapitalDelta];
z0;
ift;
TodaInit;
\[Delta]1;
TodaabOld;
GetLastSolution;
DD;
PoleList;*)
GetLastRHP;
TodaAB;
Todaab;
TodaChoose;
TodaABAuto;
TodaabAuto;
(*LogFun;*)
contours;
TPoints;
CSPoints;
(*Func;
Func2;
XX;
sing;*)
\[Delta];
U;
ift;
z0;
Begin["Private`"];


z0[n_,t_]:=IntervalToTopCircle[-n/t]Exp[I 100$MachineEpsilon];
\[Rho]0[n_,t_]:=Im[z0[n,t]];
z0i[n_,t_]:=1/z0[n,t];
z0[_,t_?ZeroQ]=\[Infinity];
SetScatteringData[{rr_,ma_,mc_},{rr1_,ma1_,mc1_}]:=Module[{},
R1[k_]:=rr[k];
R2[k_]:=rr1[k];
\[CapitalLambda]1=ma;
\[CapitalLambda]2=ma1;
c1=mc;
c2=mc1;
R=R2;
c=c2;
\[CapitalLambda]=\[CapitalLambda]2;
Ri[k_]:=-R[1/k];
\[Tau][k_]:=1+ R[k]Ri[k];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
];
GetLastRHP[]:=lastrhp;
GetLastSolution[]:=innersolution;
(*SetScatteringData[aa_,bb_,rr_,ma_,a_,b_]:=Module[{},
r[k_]:=rr[k];
ri[k_]:=-rr[1/k];
A=ma;
\[Tau][k_]:=1+ r[k]ri[k];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
c = Residues[a,b,ma,];
];*)
SetParams[nu_,rad1_,tol_,sN_,bN_]:=Module[{},
strip=nu; (*parameter for width of strip of analyticity*)
rad=rad1;
globalTol=tol;
smallN=sN;
largeN=bN;
expconst=10^(0);
eps=.01;(*size of subdivision near 1*)
StartToda[];
TodaInit[];
];
GetScatteringData[]:=Module[{},{r,A,c}];


(* Normalized at +\[Infinity], behaves like \[Zeta]^(\[Sigma]n) *)
Jost[\[Zeta]_,+1,\[Sigma]_,nn_,a_,b_]:=Module[{\[Phi],n},
\[Phi][nn]=1;
\[Phi][nn-1]=1;
n=nn-2;
While[n>=-1,
\[Phi][n]=-(\[Zeta]^\[Sigma]/a[n])(\[Zeta]^\[Sigma] a[n+1]\[Phi][n+2]+(b[n+1]-(\[Zeta]+1/\[Zeta])/2)\[Phi][n+1]);
n=n-1;
];
\[Phi][#]\[Zeta]^(\[Sigma] #)&
];
(* Normalized at -\[Infinity], behaves like \[Zeta]^(-\[Sigma]n) 
Maybe we can compile these ? *)
Jost[\[Zeta]_,-1,\[Sigma]_,nn_,a_,b_]:=Module[{\[Phi],n},
\[Phi][-nn]=1;
\[Phi][-nn+1]=1;
n=-nn+2;
While[n<=1,
\[Phi][n]=-(\[Zeta]^\[Sigma]/a[n-1])(\[Zeta]^\[Sigma] a[n-2]\[Phi][n-2]+(b[n-1]-(\[Zeta]+1/\[Zeta])/2)\[Phi][n-1]);
n=n+1;
];
\[Phi][#]\[Zeta]^(-\[Sigma] #)&
];
JostP=Compile[{{\[Zeta],_Complex},{\[Sigma],_Integer},{nn,_Integer},{a,_Complex,1},{b,_Complex,1}},Module[{\[Phi]=a,n=nn},
\[Phi][[2nn+1]]=1;
\[Phi][[2nn]]=1;
n=2nn-1;
While[n>=nn,
\[Phi][[n]]=-(\[Zeta]^\[Sigma]/a[[n]])(\[Zeta]^\[Sigma] a[[n+1]]\[Phi][[n+2]]+(b[[n+1]]-(\[Zeta]+1/\[Zeta])/2)\[Phi][[n+1]]);
n=n-1;
];
{\[Phi][[n+2]],\[Phi][[n+3]]\[Zeta]^(\[Sigma])}
],CompilationTarget->"C"
];
JostM=Compile[{{\[Zeta],_Complex},{\[Sigma],_Integer},{nn,_Integer},{a,_Complex,1},{b,_Complex,1}},Module[{\[Phi]=a,n=nn},
\[Phi][[1]]=1;
\[Phi][[2]]=1;
n=3;
While[n<=nn+2,
\[Phi][[n]]=-(\[Zeta]^\[Sigma]/a[[n-1]])(\[Zeta]^\[Sigma] a[[n-2]]\[Phi][[n-2]]+(b[[n-1]]-(\[Zeta]+1/\[Zeta])/2)\[Phi][[n-1]]);
n=n+1;
];
{\[Phi][[nn+1]],\[Phi][[nn+2]]\[Zeta]^(-\[Sigma])}
],CompilationTarget->"C"
];
Wronski[a_,n_][f_,g_]:=a[n](f[n]g[n+1]-f[n+1]g[n]);
WronskiC[a_][f_,g_]:=a(f[[1]]g[[2]]-f[[2]]g[[1]]);
ScatteringMatrixFiniteToda[a_,b_,nn_][\[Zeta]_]:=Module[{\[Beta],\[Phi]pm,\[Phi]pp,\[Phi]mp,\[Phi]mm,\[Alpha]},
\[Phi]pm=Jost[\[Zeta],1,-1,nn,a,b];
\[Phi]pp=Jost[\[Zeta],1,1,nn,a,b];
\[Phi]mm=Jost[\[Zeta],-1,1,nn,a,b];
\[Phi]mp=Jost[\[Zeta],-1,-1,nn,a,b];
\[Beta]=(2 Wronski[a,0][\[Phi]mm,\[Phi]pm])/(\[Zeta]-1/\[Zeta]);
\[Alpha]=(2 Wronski[a,0][\[Phi]pp,\[Phi]mm])/(\[Zeta]-1/\[Zeta]);
{{Conjugate[\[Alpha]],\[Beta]},{Conjugate[\[Beta]],\[Alpha]}}];
ScatteringMatrixFiniteTodaC[a_,b_,nn_][\[Zeta]_]:=Module[{\[Beta],\[Phi]pm,\[Phi]pp,\[Phi]mp,\[Phi]mm,\[Alpha],NN,A,B},
NN=Table[i,{i,-nn,nn}];
A=a[NN];
B=b[NN];
\[Phi]pm=JostP[\[Zeta],-1,nn,A,B];
\[Phi]pp=JostP[\[Zeta],1,nn,A,B];
\[Phi]mm=JostM[\[Zeta],1,nn,A,B];
\[Phi]mp=JostM[\[Zeta],-1,nn,A,B];
\[Beta]=(2 WronskiC[a[0]][\[Phi]mm,\[Phi]pm])/(\[Zeta]-1/\[Zeta]);
\[Alpha]=(2 WronskiC[a[0]][\[Phi]pp,\[Phi]mm])/(\[Zeta]-1/\[Zeta]);
{{Conjugate[\[Alpha]],\[Beta]},{Conjugate[\[Beta]],\[Alpha]}}];


LocatePolesToda[a_,b_,n_]:=Module[{L,i},
L=ConstantArray[0.,{2n+1,2n+1}];
For[i=-n,i<=n-1,i++,
L[[i+n+1,i+n+1]]=b[i];
L[[i+n+1,i+n+2]]=a[i];
L[[i+n+2,i+n+1]]=a[i];
];
L[[2n+1,2n+1]]=b[n];
DeleteCases[Eigenvalues[L],aa_/;Abs[aa]<=1]//IntervalToInnerCircle
];
(* IntervalToInnerCircle maps eigenvalues on the line to poles for the cirle RHP INSIDE the unit circle *)
ResiduesToda[a_,b_,\[CapitalLambda]_,nn_]:=Module[{\[Zeta],i,norm,\[Phi]p,\[Phi]m,\[Phi]},
norm={};
If[\[CapitalLambda]=={},Return[norm]];

For[i=1,i<=Length[\[CapitalLambda]],i++,
\[Zeta]=\[CapitalLambda][[i]];
\[Phi]p=Jost[\[Zeta],1,1,nn,a,b];
\[Phi]m=Jost[\[Zeta],-1,1,nn,a,b];
\[Phi][n_]:=If[n >=0,\[Phi]p[n],\[Phi]m[n]\[Phi]p[0]/\[Phi]m[0]];
norm=norm~Join~{1/Sum[Abs[\[Phi][n]]^2,{n,-nn,nn}]};
];
norm
];


(*initialize functions that are expensive to evaluate*)
meps=$MachineEpsilon;
NSqrt[x_]:=Sqrt[-x](I)
NegReQ[x_]:=Re[x]<=0;
PosImQ[x_]:=Im[x]>=0;
CircSqrt[a_?NegReQ][z_]:=\!\(\*
TagBox[GridBox[{
{"\[Piecewise]", GridBox[{
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], "<=", "1"}], "&&", 
RowBox[{
RowBox[{"Im", "[", "z", "]"}], ">=", 
RowBox[{"Im", "[", "a", "]"}]}]}]},
{
RowBox[{"-", 
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}]}], 
RowBox[{
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], "<=", "1"}], "&&", 
RowBox[{
RowBox[{"Im", "[", "z", "]"}], "<", 
RowBox[{"Im", "[", "a", "]"}]}]}]},
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{
RowBox[{"Re", "[", "z", "]"}], ">", "0"}], "&&", 
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], ">", "1"}], "&&", 
RowBox[{
RowBox[{"Im", "[", "a", "]"}], "<=", 
RowBox[{"Im", "[", "z", "]"}], "<=", "0"}]}]},
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{
RowBox[{"Re", "[", "z", "]"}], ">", "0"}], "&&", 
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], ">", "1"}], "&&", 
RowBox[{"0", "<=", 
RowBox[{"Im", "[", "z", "]"}], "<=", 
RowBox[{"Im", "[", "a", "]"}]}]}]},
{
RowBox[{"-", 
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}]}], "True"}
},
AllowedDimensions->{2, Automatic},
Editable->True,
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.84]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
Selectable->True]}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.35]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}],
"Piecewise",
DeleteWithContents->True,
Editable->False,
SelectWithContents->True,
Selectable->False]\)
CircSqrt[a_?PosImQ][z_]:=\!\(\*
TagBox[GridBox[{
{"\[Piecewise]", GridBox[{
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{
RowBox[{"Re", "[", "z", "]"}], ">", "0"}], "&&", 
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], ">", "1"}], "&&", 
RowBox[{
RowBox[{"Im", "[", "a", "]"}], "<=", 
RowBox[{"Im", "[", "z", "]"}], "<=", "0"}]}]},
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{
RowBox[{"Re", "[", "z", "]"}], ">", "0"}], "&&", 
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], ">", "1"}], "&&", 
RowBox[{"0", "<=", 
RowBox[{"Im", "[", "z", "]"}], "<=", 
RowBox[{"Im", "[", "a", "]"}]}]}]},
{
RowBox[{"-", 
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}]}], "True"}
},
AllowedDimensions->{2, Automatic},
Editable->True,
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.84]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
Selectable->True]}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.35]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}],
"Piecewise",
DeleteWithContents->True,
Editable->False,
SelectWithContents->True,
Selectable->False]\)
CircSqrt[a_][z_]:=\!\(\*
TagBox[GridBox[{
{"\[Piecewise]", GridBox[{
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{
RowBox[{"Re", "[", "z", "]"}], ">", "0"}], "&&", 
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], ">", "1"}], "&&", 
RowBox[{
RowBox[{"Im", "[", "a", "]"}], "<=", 
RowBox[{"Im", "[", "z", "]"}], "<=", "0"}]}]},
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{
RowBox[{"Re", "[", "z", "]"}], ">", "0"}], "&&", 
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], ">", "1"}], "&&", 
RowBox[{"0", "<=", 
RowBox[{"Im", "[", "z", "]"}], "<=", 
RowBox[{"Im", "[", "a", "]"}]}]}]},
{
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}], 
RowBox[{
RowBox[{"Abs", "[", "z", "]"}], "<", "1"}]},
{
RowBox[{"-", 
RowBox[{"NSqrt", "[", 
RowBox[{"z", "-", "a"}], "]"}]}], "True"}
},
AllowedDimensions->{2, Automatic},
Editable->True,
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.84]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
Selectable->True]}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.35]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}],
"Piecewise",
DeleteWithContents->True,
Editable->False,
SelectWithContents->True,
Selectable->False]\)
XX[a_,b_][z_]:=CircSqrt[a][z]CircSqrt[b][z]CircSqrt[1/a][z]CircSqrt[1/b][z];
H[\[Theta]a_,\[Theta]b_][ss_]:=XX[Exp[I \[Theta]a],Exp[I \[Theta]b]][Exp[I ss](1-meps)]/Exp[2 I ss]I Exp[I ss]*Sqrt[-(\[Theta]a-ss)(\[Theta]b-ss)]/((\[Theta]a-\[Theta]b)/2)//Abs;
HT[\[Theta]a_,\[Theta]b_][ss_]:=1/2XX[Exp[I \[Theta]a],Exp[I \[Theta]b]][Exp[I ss](1-meps)]/Exp[2 I ss]I Exp[I ss]*Sqrt[-(\[Theta]a-ss)(2Pi-\[Theta]a-ss)]/((2Pi-2\[Theta]a)/2)//Abs;
\[Theta]bfun[\[Theta]a_,z0_]:=ArcCos[2 Re[z0] - Cos[\[Theta]a]];
Func[\[Theta]a_,z0_]:=If[-1<2 Re[z0] - Cos[\[Theta]a]<1,SingFun[Fun[H[\[Theta]a,\[Theta]bfun[\[Theta]a,z0]][#]&,Line[{\[Theta]bfun[\[Theta]a,z0],\[Theta]a}],40],{-1/2,-1/2}]//DomainIntegrate,0];
ZeroFun[n_,t_][x_]:=Func[x,z0[n,t]]+2 Log[Im[z0[n,t]]]/t;
Func2[\[Theta]a_,z0_]:=Module[{f},If[-1<2 Re[z0] - Cos[\[Theta]a]<1,f=SingFun[Fun[HT[\[Theta]a,\[Theta]bfun[\[Theta]a,z0]][#]&,Line[{\[Theta]a,2Pi-\[Theta]a}],40],{-1/2,-1/2}];
f//DomainIntegrate,0]
];
(*NOTE: The image of the arc (-1,z0) under Func2[#,z0]& always contains 1/2\[Rho]0^3*)
(* CODE TO TEST THESE FUNCTIONS:
a=3Pi/4//N;
	b=\[Theta]bfun[a,I]//N;
	-NIntegrate[XX[I a//Exp,I b//Exp][Exp[I y]]I Exp[-I y],{y,b,a}]
-NIntegrate[XX[I a//Exp,I b//Exp][Exp[I y]]I Exp[-I y],{y,a,Pi}]//Im
Func[a,I]
Func2[a,I] *)
ZeroFun2[n_,t_][x_]:=Func2[x,z0[n,t]]-2/t;
Bisection[F_,a_,b_]:=Module[{tol=1,A=a,B=b,new,old,FA,FB},
If[F[a]F[b]>0,Return[Null]];
FA =F[A];FB=F[B];
While[Abs[A-B] > 10^(-8),
If[FB F[(B+A)/2]<0, A = (B+A)/2];
If[FA F[(B+A)/2]<0,B=(B+A)/2];
];
A
];
TodaInit[]:=Module[{},
LogFun//Clear;
mArg[z_]:=Mod[Arg[z],2Pi];
LLog[x_]:=Log[(x+1)(1-x)];
LogFun[a_]:=LogFun[a]=Fun[LLog[#]&,Line[{a,1/a}],40];
II2[s_,a_,z_]:=Cauchy[{LogFun[a]},z];

(*This improves upon the above.  It is accurate as a \[Rule] -1
Mathematica computes lint (logarithmic integral) as the explicit integral but the branches are all mixed up.  lintfix patched up the branch issue for Re[z0]<0, for z0 near zero we use the old function, there is some branching issue here for lintfix*)

lint[a1_,b1_][z_]:=-(1/(2 \[Pi]))I (-Log[1+a1+I b1] Log[(-a1-I b1+z)/(1+z)]+Log[1+a1-I b1] Log[(-a1+I b1+z)/(1+z)]+PolyLog[2,(1+a1-I b1)/(1+z)]-PolyLog[2,(1+a1+I b1)/(1+z)]);
lintfix[a1_,b1_][z_]:=Module[{ang},
ang= a1+I b1+1//Arg;
If[-ang < Arg[z+1]<ang && Re[z]< a1,lint[a1,b1][z]-Log[1+z],lint[a1,b1][z]]
];
lint\[Infinity][a1_,b1_]:=(-2 b1+(I+I a1+b1) Log[1+a1-I b1]+(-I-I a1+b1) Log[1+a1+I b1])/(2 \[Pi]);


k[a_][z_]:=lintfix[Re[a],Im[a]][z-$MachineEpsilon];
k\[Infinity][a_]:=lint\[Infinity][Re[a],Im[a]];
llll[x_]:=Log[(1-x)];
LogFunShort//Clear;
LogFunShort[a_]:=LogFunShort[a]=Fun[llll[#]&,Line[{a,1/a}],35];
II[s_,a_,z_]:=If[Abs[a-I]>.1,Cauchy[{LogFunShort[a]},z]+k[a][z],II2[s,a,z]];
(*LLog[x_]:=Log[(x+1)(1-x)];*)

mLog[x_]:=-Log[-x]+I Pi/2;

(*LogFun2//Clear;
mLog[x_]:=-Log[-x]+I Pi/2;
LogFun2[a_]:=LogFun2[a]=Fun[mLog[#]&,Arc[0,1,{Arg[a],2Pi-Arg[a]}],largeN];
II2[s_,a_,z_]:=Cauchy[{LogFun2[a]},z];*)

(*this should be simplified using the derivation in the paper*)

sing[a_,z_]:=If[Abs[z]>=1. || Re[z]>=Re[a],II[-1,a,z],II[+1,a,z]+LLog[z]];
sing[a_,z_List]:=sing[a,#]&/@z;
(*\[Tau]r[z_]:= -\[Tau][z]/(z-1/z)^2;*)
ift//Clear;
ift[z0_,r_]:=ift[z0,r]={Fun[Log[-(1-r[#]r[1/#])/(#-1/#)^2]+2mLog[#]&,Arc[0,1,{Arg[z0],2Pi-Arg[z0]}],2largeN+40]};
(*ift[z0_,r_]:=ift[z0,r]={Fun[Log[-(1-r[#]r[1/#])/(#-1/#)^2]+2mLog[#]&,Arc[0,1,{Arg[z0],Pi-eps}],40+2largeN],Fun[Log[-(1-r[#]r[1/#])/(#-1/#)^2]+2mLog[#]&,Arc[0,1,{Pi-eps,Pi+eps}],20+smallN],Fun[Log[-(1-r[#]r[1/#])/(#-1/#)^2]+2mLog[#]&,Arc[0,1,{Arg,2Pi-Arg[z0]}],40+2largeN]};*)
(*This gives the so-called partial transmission coefficient?*)
\[Delta]//Clear;
\[Delta][s_,n_,t_,R_][z_]:= \[Delta][s,n,t,R][z]=Exp[Cauchy[ift[z0[n,t],R],z(1-100s $MachineEpsilon)]+2 sing[z0[n,t],z(1-100s $MachineEpsilon)]](z-z0[n,t])/(z+1);


(* Compute g, the g-function in the CS region*)
CSPoints//Clear;
CSPoints[n_,t_]:=CSPoints[n,t]=Module[{\[Theta]a,\[Theta]b},
\[Theta]a=Bisection[ZeroFun[n,t],Pi,Arg[z0[n,t]]+100$MachineEpsilon];
If[\[Theta]a==Null,Return[{-1,z0[n,t]}]];
\[Theta]b=\[Theta]bfun[\[Theta]a,z0[n,t]];
Exp[I{\[Theta]a,\[Theta]b}]
];
iMM[z_]:=I (z+1)/(z-1);
MM[x_]:=(I+x)/(-I+x);
\[Theta]t[n_,t_][\[Zeta]_]:=(\[Zeta]-\[Zeta]^(-1))+ 2n Log[\[Zeta]]/t;
V[nn_,T_][k_]:=\[Theta]t[nn,T][MM[k]];
A[n_,t_]:=CSPoints[n,t][[1]]//iMM;
B[n_,t_]:=CSPoints[n,t][[2]]//iMM;
\[Alpha][n_,t_]:=CSPoints[n,t][[1]];
\[Beta][n_,t_]:=CSPoints[n,t][[2]];

iftcs//Clear;
iftcs[z0_,r_]:=iftcs[z0,r]={Fun[Log[-(1-r[#]r[1/#])/(#-1/#)^2]+2mLog[#]&,Arc[0,1,{Arg[z0],2Pi-Arg[z0]}],40+2largeN]};
ci//Clear;
ci[n_,t_]:=ci[n,t]={Fun[V[n,t]'[#]&,Line[{-B[n,t],-A[n,t]}],40],Fun[V[n,t]'[#]&,Line[{A[n,t],B[n,t]}],40]}//CauchyInverseCurves;
g[p_,n_,t_][z_]:=-t(CauchyInverseIntegral[-p,#,iMM[z]]&/@ci[n,t]//Total);
(*gg[p_,n_,t_][z_]:=-t(CauchyInverseIntegral[-p,#,z]&/@ci[n,t]//Total);*)
d1[n_,t_]:= g[1,n,t][-1]-g[-1,n,t][-1];
\[Delta]d1[s_,n_,t_][z_]:=Cauchy[s,{Fun[d1[n,t]&,Arc[0,1,{\[Alpha][n,t]//Arg,2Pi-Arg[\[Alpha][n,t]]}],2]},z]//Exp;
\[Delta]cs//Clear;
\[Delta]cs[s_,n_,t_,R_][z_]:=\[Delta]cs[s,n,t,R][z]=\[Delta]d1[s,n,t][z(1-100s $MachineEpsilon)]*Exp[Cauchy[iftcs[\[Alpha][n,t],R],z(1-100s $MachineEpsilon)]+2 sing[\[Alpha][n,t],z(1-100s $MachineEpsilon)]](z-\[Alpha][n,t])/(z+1);
test[s_,n_,t_][z_]:=Exp[Cauchy[iftcs[\[Alpha][n,t],R],z(1-100s $MachineEpsilon)]+2 sing[\[Alpha][n,t],z(1-100s $MachineEpsilon)]](z-\[Alpha][n,t])/(z+1);

(* compute gt, the g-function in the transition region*)
(*TODO: Does TPoints work?*)
TPoints//Clear;TPoints[n_,t_]:=TPoints[n,t]=Module[{\[Theta]a,\[Theta]b},
\[Theta]a=Bisection[ZeroFun2[n,t],Arg[z0[n,t]]+100$MachineEpsilon,Pi-10$MachineEpsilon];
If[\[Theta]a==Null,Return[{-1,z0[n,t]}]];
\[Theta]b=\[Theta]bfun[\[Theta]a,z0[n,t]];
Exp[I{\[Theta]a,\[Theta]b}]
];
At[n_,t_]:=CSPoints[n,t][[1]]//iMM;
Bt[n_,t_]:=CSPoints[n,t][[2]]//iMM;
\[Alpha]t[n_,t_]:=CSPoints[n,t][[1]];
\[Beta]t[n_,t_]:=CSPoints[n,t][[2]];

cit//Clear;
cit[n_,t_]:=cit[n,t]={Fun[V[n,t]'[#]&,Line[{-Bt[n,t],-At[n,t]}],30],Fun[V[n,t]'[#]&,Line[{At[n,t],Bt[n,t]}],30]}//CauchyInverseCurves;

gt[p_,n_,t_][z_]:=-t(CauchyInverseIntegral[-p,#,iMM[z]]&/@cit[n,t]//Total);
(*gg[p_,n_,t_][z_]:=-t(CauchyInverseIntegral[-p,#,z]&/@ci[n,t]//Total);*)

];


(* Find the minimum distance among all the elements of x *)
MinDist[x_]:=Module[{min,i,j},
min=1000;
For[i=1,i<=Length[x],i++,
For[j=i+1,j<=Length[x],j++,
If[Abs[x[[i]]-x[[j]]]<min,min=Abs[x[[i]]-x[[j]]]];
];
];
min
];
(* Determined whether the growth at a eigenvalue (or pole) should inverted *)
Swit[n_,t_,\[CapitalLambda]_,c_]:=DeleteCases[Table[If[Abs[\[CapitalLambda][[i]] c[[i]] Exp[\[Theta][n,t][\[CapitalLambda][[i]]]]]>expconst,i,0],{i,1,Length[c]}],a_/;a==0];
(* create a product of appropriate rational functions over the index set from Swit, just one function for each n and t *)
DD[n_,t_][z_]:=Module[{s,f},
s=Swit[n,t,\[CapitalLambda],c];
f=Product[(z-\[CapitalLambda][[s[[i]]]])/(z \[CapitalLambda][[s[[i]]]]-1),{i,1,Length[s]}];
{{f,0},{0,1/f}}
];
DD[n_,t_][\[Infinity]]:=Module[{s,f},
s=Swit[n,t,\[CapitalLambda],c];
f=Product[(1)/( \[CapitalLambda][[s[[i]]]]),{i,1,Length[s]}];
{{f,0},{0,1/f}}
];
DDsamp[n_,t_][z_]:={{1,0},{0,1}};
(*Lensing of unit circle RHP: L, U, M, P, Diag*)

\[Theta][n_,t_][\[Zeta]_]:=t(\[Zeta]-\[Zeta]^(-1))+ 2n Log[\[Zeta]];
L[x_,t_][k_]:=({
 {1, 0},
 {R[k]/\[Tau][k] Exp[\[Theta][x,t][k]], 1}
});
Lsamp[x_,t_][k_]:=({
 {1, 0},
 {Exp[\[Theta][x,t][k]], 1}
});
U[x_,t_][k_]:=({
 {1, Ri[k]/\[Tau][k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Ui[x_,t_][k_]:=({
 {1, -(Ri[k]/\[Tau][k])Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Usamp[x_,t_][k_]:=({
 {1, Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Ri[k_]:=-R[1/k];
Diag[x_,t_][k_]:=({
 {\[Tau][k], 0},
 {0, 1/\[Tau][k]}
});
Diagsamp[x_,t_][k_]:=({
 {2, 0},
 {0, 2}
});
Diagi[x_,t_][k_]:=({
 {1/\[Tau][k], 0},
 {0, \[Tau][k]}
});
Diagisamp[x_,t_][k_]:=({
 {2, 0},
 {0, 2}
});
M[x_,t_][k_]:=({
 {1, Ri[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Msamp[x_,t_][k_]:=({
 {1, Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
P[x_,t_][k_]:=({
 {1, 0},
 {R[k] Exp[\[Theta][x,t][k]], 1}
});
Pin[x_,t_][k_]:=({
 {1, 0},
 {-R[k] Exp[\[Theta][x,t][k]], 1}
});
Psamp[x_,t_][k_]:=({
 {1, 0},
 { Exp[\[Theta][x,t][k]], 1}
});
J[n_,t_][x_]:={{1-Abs[R[x]]^2,-Conjugate[R[x]]Exp[-\[Theta][n,t][x]] },{R[x]Exp[\[Theta][n,t][x]] ,1}};
Jsamp[n_,t_][x_]:={{1,1},{1,1}};

(* jumps around poles, T is the original deformation, +1 is interior, -1 is exterior *)
T[+1][n_,t_,a_,c_][z_]:=({
 {1, 0},
 {a c Exp[\[Theta][n,t][a]]/(z-a), 1}
});
T[-1][n_,t_,a_,c_][z_]:=({
 {1,  c z Exp[\[Theta][n,t][a]]/(z-1/a)},
 { 0, 1}
});
(* inverting the exponent *)
S[+1][n_,t_,a_,c_][z_]:=({
 {1, ( z -a)/(a c Exp[\[Theta][n,t][a]])},
 {0, 1}
});
S[-1][n_,t_,a_,c_][z_]:=({
 {1, 0},
 { ( a z-1)/(a c z Exp[\[Theta][n,t][a]]), 1}
});
(* create circles around a and 1/a, only used for poles, note orientation *)
ContourArray[+1,r_,a_]:={Arc[a,r,{0,Pi}],Arc[a,r,{Pi,2Pi}]};
ContourArray[-1,r_,a_]:={Arc[1/a,r,{0,-Pi}],Arc[1/a,r,{-Pi,-2Pi}]};

\[CapitalDelta][s_,n_,t_][z_]:={{\[Delta][s,n,t,R][z],0},{0,1/\[Delta][s,n,t,R][z]}};
\[CapitalDelta]samp[s_,n_,t_][z_]:={{1,0},{0,1}};
\[CapitalDelta]i[s_,n_,t_][z_]:={{1/\[Delta][s,n,t,R][z],0},{0,\[Delta][s,n,t,R][z]}};
\[CapitalDelta]isamp[s_,n_,t_][z_]:={{1,0},{0,1}};
\[CapitalDelta]PUi[n_,t_][z_]:=\[CapitalDelta][1,n,t][z].P[n,t][z].Ui[n,t][z];
\[CapitalDelta]PUisamp[n_,t_][z_]:=Psamp[n,t][z].Inverse[Usamp[n,t][z]];
\[CapitalDelta]Ui[n_,t_][z_]:=\[CapitalDelta][1,n,t][z].Ui[n,t][z];
\[CapitalDelta]Uisamp[n_,t_][z_]:=Inverse[Usamp[n,t][z]];
\[CapitalDelta]LD[n_,t_][z_]:=\[CapitalDelta][1,n,t][z].L[n,t][z].Diag[n,t][z];
\[CapitalDelta]LDsamp[n_,t_][z_]:=Lsamp[n,t][z]
\[CapitalDelta]D[n_,t_][z_]:=If[Abs[z]>1.,\[CapitalDelta][-1,n,t][z].Diag[n,t][z],\[CapitalDelta][+1,n,t][z]];
\[CapitalDelta]Dsamp[n_,t_][z_]:={{2,0},{0,2}};

\[CapitalDelta]cs[s_,n_,t_][z_]:={{\[Delta]cs[s,n,t,R][z],0},{0,1/\[Delta]cs[s,n,t,R][z]}};
\[CapitalDelta]cssamp[s_,n_,t_][z_]:={{1,0},{0,1}};
\[CapitalDelta]csi[s_,n_,t_][z_]:={{1/\[Delta]cs[s,n,t,R][z],0},{0,\[Delta]cs[s,n,t,R][z]}};
\[CapitalDelta]csisamp[s_,n_,t_][z_]:={{1,0},{0,1}};


gsamp[p_,n_,t_][z_]:=If[Abs[z+1]<4,.1Abs[t]Sign[Abs[z]-1],0];
\[Phi][p_,n_,t_][z_]:=DiagonalMatrix[{Exp[g[p,n,t][z]],Exp[-g[p,n,t][z]]}];
\[Phi]i[p_,n_,t_][z_]:=DiagonalMatrix[{Exp[-g[p,n,t][z]],
Exp[g[p,n,t][z]]}];
\[Phi]samp[p_,n_,t_][z_]:=2IdentityMatrix[2];
\[Phi]isamp[p_,n_,t_][z_]:=1/2IdentityMatrix[2];

\[CapitalDelta]\[Phi][p_,n_,t_][z_]:=\[CapitalDelta]cs[p,n,t][z].\[Phi]i[p,n,t][z];
\[CapitalDelta]\[Phi]i[p_,n_,t_][z_]:=\[CapitalDelta]csi[p,n,t][z].\[Phi][p,n,t][z];
\[CapitalDelta]\[Phi]samp[p_,n_,t_][z_]:=\[Phi]isamp[p,n,t][z];
\[CapitalDelta]\[Phi]isamp[p_,n_,t_][z_]:=\[Phi]samp[p,n,t][z];

(*jumps away from both \[Alpha] and \[Beta]*)
Jcs[n_,t_][z_]:=\[CapitalDelta]\[Phi][-1,n,t][z].J[n,t][z].\[CapitalDelta]\[Phi]i[1,n,t][z];
Ucs[n_,t_][z_]:=\[CapitalDelta]\[Phi][1,n,t][z].U[n,t][z].\[CapitalDelta]\[Phi]i[1,n,t][z];
Lcs[n_,t_][z_]:=\[CapitalDelta]\[Phi][-1,n,t][z].L[n,t][z].\[CapitalDelta]\[Phi]i[-1,n,t][z];
Pcs[n_,t_][z_]:=\[CapitalDelta]\[Phi][1,n,t][z].P[n,t][z].\[CapitalDelta]\[Phi]i[1,n,t][z];
Mcs[n_,t_][z_]:=\[CapitalDelta]\[Phi][-1,n,t][z].M[n,t][z].\[CapitalDelta]\[Phi]i[-1,n,t][z];

Jcssamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[-1,n,t][z].Jsamp[n,t][z].\[CapitalDelta]\[Phi]isamp[1,n,t][z];
Ucssamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[1,n,t][z].Usamp[n,t][z].\[CapitalDelta]\[Phi]isamp[1,n,t][z];
Lcssamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[-1,n,t][z].Lsamp[n,t][z].\[CapitalDelta]\[Phi]isamp[-1,n,t][z];
Pcssamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[1,n,t][z].Psamp[n,t][z].\[CapitalDelta]\[Phi]isamp[1,n,t][z];
Mcssamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[-1,n,t][z].Msamp[n,t][z].\[CapitalDelta]\[Phi]isamp[-1,n,t][z];

(*jumps near \[Beta]*)
\[CapitalDelta]\[Phi]M\[CapitalDelta]i[n_,t_][z_]:=\[CapitalDelta]\[Phi][-1,n,t][z].M[n,t][z].\[CapitalDelta]csi[-1,n,t][z];
\[CapitalDelta]\[Phi]Pi\[CapitalDelta]i[n_,t_][z_]:=\[CapitalDelta]\[Phi][+1,n,t][z].Inverse[P[n,t][z]].\[CapitalDelta]csi[+1,n,t][z];

\[CapitalDelta]\[Phi]M\[CapitalDelta]isamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[-1,n,t][z].Msamp[n,t][z]
\[CapitalDelta]\[Phi]Pi\[CapitalDelta]isamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[+1,n,t][z].Inverse[Psamp[n,t][z]]

(*jumps near \[Alpha]*)
\[CapitalDelta]\[Phi]L[n_,t_][z_]:=\[CapitalDelta]\[Phi][-1,n,t][z].L[n,t][z];
\[CapitalDelta]\[Phi]LD[n_,t_][z_]:=\[CapitalDelta]\[Phi][-1,n,t][z].L[n,t][z].Diag[n,t][z];
\[CapitalDelta]\[Phi]Ui[n_,t_][z_]:=\[CapitalDelta]\[Phi][+1,n,t][z].Ui[n,t][z];
\[CapitalDelta]\[Phi]D[n_,t_][z_]:=If[Abs[z]>1,\[CapitalDelta]\[Phi][-1,n,t][z].Diag[n,t][z],\[CapitalDelta]\[Phi][+1,n,t][z]];

\[CapitalDelta]\[Phi]Lsamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[-1,n,t][z].Lsamp[n,t][z];
\[CapitalDelta]\[Phi]LDsamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[-1,n,t][z].Lsamp[n,t][z].Diagsamp[n,t][z];
\[CapitalDelta]\[Phi]Uisamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[+1,n,t][z].Inverse[Usamp[n,t][z]];
\[CapitalDelta]\[Phi]Dsamp[n_,t_][z_]:=\[CapitalDelta]\[Phi]samp[-1,n,t][z];

(*Transition Jumps*)
gsamp[p_,n_,t_][z_]:=If[Abs[z+1]<4,.1Abs[t]Sign[Abs[z]-1],0];
\[Phi]t[p_,n_,t_][z_]:=DiagonalMatrix[{Exp[gt[p,n,t][z]],Exp[-gt[p,n,t][z]]}];
\[Phi]ti[p_,n_,t_][z_]:=DiagonalMatrix[{Exp[-gt[p,n,t][z]],
Exp[gt[p,n,t][z]]}];
\[Phi]tsamp[p_,n_,t_][z_]:=2IdentityMatrix[2];
\[Phi]tisamp[p_,n_,t_][z_]:=1/2IdentityMatrix[2];

(*jumps away from both \[Alpha] and \[Beta]*)
Jt[n_,t_][z_]:=\[Phi]ti[-1,n,t][z].J[n,t][z].\[Phi]t[1,n,t][z];
Ut[n_,t_][z_]:=\[Phi]ti[1,n,t][z].U[n,t][z].\[Phi]t[1,n,t][z];
Lt[n_,t_][z_]:=\[Phi]ti[-1,n,t][z].L[n,t][z].\[Phi]t[-1,n,t][z];
Pt[n_,t_][z_]:=\[Phi]ti[1,n,t][z].P[n,t][z].\[Phi]t[1,n,t][z];
Mt[n_,t_][z_]:=\[Phi]ti[-1,n,t][z].M[n,t][z].\[Phi]t[-1,n,t][z];

Jtsamp[n_,t_][z_]:=\[Phi]tisamp[-1,n,t][z].Jsamp[n,t][z].\[Phi]tsamp[1,n,t][z];
Utsamp[n_,t_][z_]:=\[Phi]tisamp[1,n,t][z].Usamp[n,t][z].\[Phi]tsamp[1,n,t][z];
Ltsamp[n_,t_][z_]:=\[Phi]tisamp[-1,n,t][z].Lsamp[n,t][z].\[Phi]tsamp[-1,n,t][z];
Ptsamp[n_,t_][z_]:=\[Phi]tisamp[1,n,t][z].Psamp[n,t][z].\[Phi]tsamp[1,n,t][z];
Mtsamp[n_,t_][z_]:=\[Phi]tisamp[-1,n,t][z].Msamp[n,t][z].\[Phi]tsamp[-1,n,t][z];

(*jumps near \[Beta]*)
\[Phi]iM[n_,t_][z_]:=\[Phi]ti[-1,n,t][z].M[n,t][z];
\[Phi]iPi[n_,t_][z_]:=\[Phi]ti[+1,n,t][z].Inverse[P[n,t][z]];

\[Phi]iMsamp[n_,t_][z_]:=\[Phi]tisamp[-1,n,t][z].Msamp[n,t][z]
\[Phi]iPisamp[n_,t_][z_]:=\[Phi]tisamp[+1,n,t][z].Inverse[Psamp[n,t][z]]

(*jumps near \[Alpha]*)
\[Phi]iL[n_,t_][z_]:=\[Phi]ti[-1,n,t][z].L[n,t][z];
\[Phi]iLD[n_,t_][z_]:=\[Phi]ti[-1,n,t][z].L[n,t][z].Diag[n,t][z];
\[Phi]iUi[n_,t_][z_]:=\[Phi]ti[+1,n,t][z].Ui[n,t][z];

\[Phi]iLsamp[n_,t_][z_]:=\[Phi]tisamp[-1,n,t][z].Lsamp[n,t][z];
\[Phi]iLDsamp[n_,t_][z_]:=\[Phi]tisamp[-1,n,t][z].Lsamp[n,t][z].Diagsamp[n,t][z];
\[Phi]iUisamp[n_,t_][z_]:=\[Phi]tisamp[+1,n,t][z].Inverse[Usamp[n,t][z]];



BasicCross={Line[{0,Exp[I Pi/4]}],Line[{Exp[-3Pi/4I],0}],Line[{Exp[3I Pi/4],0}],Line[{0,Exp[-I Pi/4]}]};
HoleCross[r_]:={Line[{r Exp[I Pi/4],Exp[I Pi/4]}],Line[{Exp[-3Pi/4I],r Exp[-3Pi/4I]}],Line[{Exp[3I Pi/4],r Exp[3I Pi/4]}],Line[{r Exp[-I Pi/4],Exp[-I Pi/4]}]};
(* first contour is inside, further along (pos orientation) *)
(* second is in the same direction as the first (outside circle) *)
(* third is inside, fourth is outside *)
SmallCross[z0_,rad_]:=BasicCross *rad Exp[I (Arg[z0]+Pi/2)]+z0;
SmallHoleCross[z0_,rad_,f_]:=HoleCross[f] *rad Exp[I (Arg[z0]+Pi/2)]+z0;
(*ordered counterclockwise from the furthest right intersection point
with the real axis*)
RightLens[z0_,rad_,bool_,f_]:=Module[{cont,contc,a1,a2,a3,a4},
If[bool,cont=SmallHoleCross[z0,rad,f];
contc=SmallHoleCross[1/z0,rad,f];,
cont=SmallCross[z0,rad];
contc=SmallCross[1/z0,rad];
];
a3=cont[[3]][[1]][[1]];
a1=cont[[1]][[1]][[2]];
a2=cont[[2]][[1]][[1]];
a4=cont[[4]][[1]][[2]];
{Arc[0,a2//Abs,{0,a2//Arg}],
cont[[2]],
cont[[3]],
Arc[0,a3//Abs,{0,a3//Arg}],
Arc[0,a3//Abs,{2Pi-Arg[a3],2Pi}],
contc[[1]],
contc[[4]],
Arc[0,a2//Abs,{2Pi-Arg[a2],2Pi}]}
];
RightLensClosed[z0_]:=Module[{cont,contc,a,a1,a2,a3,a4},
a=1+strip-z0;
a1=-Sqrt[(1+strip)^2-a^2]+I a;
a2=Conjugate[a1];
a=1/z0-(1-strip);
a3 =-Sqrt[(1-strip)^2-a^2]+I a;
a4 =Conjugate[a3];
{Arc[0,1+strip,{0,Arg[a1]}],
Line[{a1,-z0}],
Line[{-z0,a2}],
Arc[0,1+strip,{Arg[a2],0}],
Arc[0,1-strip,{0,Arg[a3]}],
Line[{a3,-1/z0}],
Line[{-1/z0,a4}],
Arc[0,1-strip,{Arg[a4],0}]
}
];
LeftLens[z0_,rad_,bool_,f_]:=Module[{cont,contc,a1,a2,a3,a4},
If[bool,cont=SmallHoleCross[z0,rad,f];
contc=SmallHoleCross[1/z0,rad,f];,
cont=SmallCross[z0,rad];
contc=SmallCross[1/z0,rad];
];
a3=cont[[3]][[1]][[1]];
a1=cont[[1]][[1]][[2]];
a2=cont[[2]][[1]][[1]];
a4=cont[[4]][[1]][[2]];
{Arc[0,a1//Abs,{a1//Arg,Pi}],
cont[[1]],
cont[[4]],
Arc[0,a4//Abs,{a4//Arg,Pi}],
Arc[0,a4//Abs,{Pi,2Pi-Arg[a4]}],
contc[[2]],
contc[[3]],
Arc[0,a1//Abs,{Pi,2Pi-Arg[a1]}]}
];
LeftLensCS[z0_,rad_,bool_,f_]:=Module[{cont,contc,a1,a2,a3,a4},
If[bool,cont=SmallHoleCross[z0,rad,f];
contc=SmallHoleCross[1/z0,rad,f];,
cont=SmallCross[z0,rad];
contc=SmallCross[1/z0,rad];
];
a3=cont[[3]][[1]][[1]];
a1=cont[[1]][[1]][[2]];
a2=cont[[2]][[1]][[1]];
a4=cont[[4]][[1]][[2]];
{Arc[0,a1//Abs,{a1//Arg,2Pi-Arg[a1]}],
cont[[1]],
cont[[4]],
Arc[0,a4//Abs,{a4//Arg,2Pi-Arg[a4]}],
contc[[2]],
contc[[3]]}
(*A simplification on the angle...*)
];
RightSemi[z0_]:={Arc[0,1,{0,Arg[z0]}],Arc[0,1,{2Pi-Arg[z0],2Pi}]};
LeftSemi[z0_]:={Arc[0,1,{Arg[z0],Pi-eps}],Arc[0,1,{Pi-eps,Pi+eps}],Arc[0,1,{Pi+eps,2Pi-Arg[z0]}]};
LeftSemiSmall[z0_]:={Arc[0,1,{Arg[z0],2Pi-Arg[z0]}]};
(*OuterLens[z0_,rad_]:=Module[{cont,a1,a2},
cont=SmallCross[z0,rad];
a1=cont[[2]][[1]][[1]];
a2=cont[[4]][[1]][[2]];
{Arc[0,a1//Abs,{0,a1//Arg}],Arc[0,a1//Abs,{2Pi-Arg[a1],2Pi}],Arc[0,a2//Abs,{a2//Arg,Pi}],Arc[0,a2//Abs,{Pi ,2Pi- Arg[a2]}]}
];*)
FullCircle[rad_,eps_]:={Arc[0,rad,{-eps,eps}],Arc[0,rad,{eps,Pi-eps}],Arc[0,rad,{Pi-eps,Pi+eps}],Arc[0,rad,{Pi+eps,2Pi-eps}]};


CircleRHP[0][n_,t_]:=Module[{Jumps,Domain,Points,i},
Domain={Arc[0,1,{-eps,eps}],Arc[0,1,{eps,Pi-eps}],Arc[0,1.,{Pi-eps,Pi+eps}],Arc[0,1.,{Pi+eps,2Pi-eps}]};
Jumps=Table[J[n,t],{i,1,Length[Domain]}];
Points=Table[largeN,{i,1,Length[Domain]}];
Points[[2]]=Points[[2]]*4;
Points[[-2]]=Points[[-2]]*4;
{ConjugateJumps[Jumps,DD[n,t]],Domain,Points}
];
CircleRHPsamp[0][n_,t_]:=Module[{Jumps,Domain,Points,i},
Domain={Arc[0,1,{-eps,eps}],Arc[0,1,{eps,Pi-eps}],Arc[0,1.,{Pi-eps,Pi+eps}],Arc[0,1.,{Pi+eps,2Pi-eps}]};
Jumps=Table[Jsamp[n,t],{i,1,Length[Domain]}];
Points=Table[largeN,{i,1,Length[Domain]}];
Points[[2]]=Points[[2]]*4;
Points[[-2]]=Points[[-2]]*4;
{Jumps,Domain,Points}
];



(*RHP with no conjugation (z0 near -1?) *)
CircleRHP[1][n_,t_]:=Module[{Domain,Jumps,NumPts,z,i},
z=If[t>0,z0[n,t],I];
Domain=Join[RightLens[z,strip,False,1/4],LeftSemiSmall[z]];
Jumps={M[n,t],M[n,t],P[n,t],P[n,t],P[n,t],P[n,t],M[n,t],M[n,t],J[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
NumPts[[-1]]=2 largeN;
{ConjugateJumps[Jumps,DD[n,t]],Domain,NumPts}
];
CircleRHPsamp[1][n_,t_]:=Module[{Domain,Jumps,NumPts,z,i},
z=If[t>0,z0[n,t],I];
Domain=Join[RightLens[z,strip,False,1/4],LeftSemiSmall[z]];
Jumps={Msamp[n,t],Msamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t],Msamp[n,t],Msamp[n,t],Jsamp[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
NumPts[[-1]]=2 largeN;
{Jumps,Domain,NumPts}
];


CR[x_]:=Conjugate[Reverse[x]];
CircleRHP[2][n_,t_]:=Module[{Domain,NumPts,z,i,p1,p2,p3,p4,UpperDomain,UpperJumps,LowerDomain,Jumps,LowerJumps,InnerNumPts,smallrad},
smallrad=Min[.25/(1.+Abs[t]/10)^(1/2)];
z=If[t>0,z0[n,t],I];
Domain=Join[RightLens[z,strip,True,smallrad],LeftLens[z,strip,True,smallrad]];
Jumps={M[n,t],M[n,t],P[n,t],P[n,t],P[n,t],P[n,t],M[n,t],M[n,t],U[n,t],U[n,t],L[n,t],L[n,t],L[n,t],L[n,t],U[n,t],U[n,t]};
Jumps=ConjugateJumps[Jumps,\[CapitalDelta]i[1,n,t]];
NumPts={largeN,smallN,smallN,largeN,largeN,smallN,smallN,largeN,largeN,smallN,smallN,largeN,largeN,smallN,smallN,largeN};
p1=Domain[[2]][[1]]//Last;
p4=Domain[[3]][[1]]//Last;
p3=Domain[[10]][[1]]//First;
p2=Domain[[11]][[1]]//First;

UpperDomain={Line[{p1,p2}],Line[{p2,p3}],Line[{p3,p4}],Line[{p4,p1}]};
LowerDomain={Line[{p2,p3}//CR],Line[{p3,p4}//CR],Line[{p4,p1}//CR],Line[{p1,p2}//CR]};
UpperJumps={\[CapitalDelta]LD[n,t],\[CapitalDelta]D[n,t],\[CapitalDelta]Ui[n,t],\[CapitalDelta]PUi[n,t]};
LowerJumps={\[CapitalDelta]D[n,t],\[CapitalDelta]Ui[n,t],\[CapitalDelta]PUi[n,t],\[CapitalDelta]LD[n,t]};
InnerNumPts=Table[smallN,{i,1,8}];
{ConjugateJumps[Join[Jumps,UpperJumps,LowerJumps],DD[n,t]],Join[Domain,UpperDomain,LowerDomain],Join[NumPts,InnerNumPts]}
];
CircleRHPsamp[2][n_,t_]:=Module[{Domain,NumPts,z,i,p1,p2,p3,p4,UpperDomain,UpperJumps,LowerDomain,Jumps,LowerJumps,InnerNumPts,smallrad},
smallrad=Min[.25/(1.+Abs[t]/10)^(1/2)];
z=If[t>0,z0[n,t],I];
Domain=Join[RightLens[z,strip,True,smallrad],LeftLens[z,strip,True,smallrad]];
Jumps={Msamp[n,t],Msamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t],Msamp[n,t],Msamp[n,t],Usamp[n,t],Usamp[n,t],Lsamp[n,t],Lsamp[n,t],Lsamp[n,t],Lsamp[n,t],Usamp[n,t],Usamp[n,t]};
NumPts={largeN,smallN,smallN,largeN,largeN,smallN,smallN,largeN,largeN,smallN,smallN,largeN,largeN,smallN,smallN,largeN};
p1=Domain[[2]][[1]]//Last;
p4=Domain[[3]][[1]]//Last;
p3=Domain[[10]][[1]]//First;
p2=Domain[[11]][[1]]//First;

UpperDomain={Line[{p1,p2}],Line[{p2,p3}],Line[{p3,p4}],Line[{p4,p1}]};
LowerDomain={Line[{p2,p3}//CR],Line[{p3,p4}//CR],Line[{p4,p1}//CR],Line[{p1,p2}//CR]};
UpperJumps={\[CapitalDelta]LDsamp[n,t],\[CapitalDelta]Dsamp[n,t],\[CapitalDelta]Uisamp[n,t],\[CapitalDelta]PUisamp[n,t]};
LowerJumps={\[CapitalDelta]Dsamp[n,t],\[CapitalDelta]Uisamp[n,t],\[CapitalDelta]PUisamp[n,t],\[CapitalDelta]LDsamp[n,t]};
InnerNumPts=Table[smallN,{i,1,8}];
{Join[Jumps,UpperJumps,LowerJumps],Join[Domain,UpperDomain,LowerDomain],Join[NumPts,InnerNumPts]}
];



(*RHP with no conjugation (z0 near -1?) *)
CircleRHP[3][n_,t_]:=Module[{Domain,Jumps,NumPts,z,i},
z=Abs[z0[n,t]];
If[z>=strip+1,
Domain=Join[FullCircle[1+strip,eps],FullCircle[1-strip,eps]];
Jumps={M[n,t],M[n,t],M[n,t],M[n,t],P[n,t],P[n,t],P[n,t],P[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
];
If[1+strip>z>1+strip/100,
Domain=RightLensClosed[z];
Jumps={M[n,t],M[n,t],M[n,t],M[n,t],P[n,t],P[n,t],P[n,t],P[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
];
If[1+strip/100>=z>=1,
Domain=RightLensClosed[z+strip/100];
Jumps={M[n,t],M[n,t],M[n,t],M[n,t],P[n,t],P[n,t],P[n,t],P[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
];

{ConjugateJumps[Jumps,DD[n,t]],Domain,NumPts}
];
CircleRHPsamp[3][n_,t_]:=Module[{Domain,Jumps,NumPts,z,i},
z=Abs[z0[n,t]];
If[z>=strip+1,
Domain=Join[FullCircle[1+strip,eps],FullCircle[1-strip,eps]];
Jumps={Msamp[n,t],Msamp[n,t],Msamp[n,t],Msamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
];
If[1+strip>z>1+strip/100,
Domain=RightLensClosed[z];
Jumps={Msamp[n,t],Msamp[n,t],Msamp[n,t],Msamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
];
If[1+strip/100>=z>=1,
Domain=RightLensClosed[z+strip/100];
Jumps={Msamp[n,t],Msamp[n,t],Msamp[n,t],Msamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t],Psamp[n,t]};
NumPts=Table[largeN,{i,1,Length[Domain]}];
];

{Jumps,Domain,NumPts}
];



CircleRHP[4][n_,t_]:=Module[{Domain,NumPts,a,b,i,p1,p2,p3,p4,pa,pb,UpperDomain,UpperJumps,LowerDomain,Jumps,LowerJumps,InnerNumPts,smallrada,smallradb},
{a,b}=CSPoints[n,t];
smallradb=2Min[strip/2,Abs[a-b]/2];(*fix this scaling?*)
smallrada=Min[8smallradb,Im[a]/2];(*fix this scaling?*)
Domain=Join[RightLens[b,strip,True,smallradb],LeftLensCS[a,Min[strip,Im[a]/2],True,smallrada]];
p1=Domain[[2]][[1]]//Last;
p4=Domain[[3]][[1]]//Last;
p3=Domain[[10]][[1]]//First;
p2=Domain[[11]][[1]]//First;

pa=Exp[I (Arg[a]- ArcSin[smallrada/2]/8)];
pb=Exp[I (Arg[b]+ ArcSin[smallradb/2]/4)];


(*p2,p3 have more negative real parts*)
UpperDomain={Line[{p4,p1}],Line[{pb,p4}],Line[{p1,pb}],Line[{p2,p3}],Line[{pa,p2}],Line[{p3,pa}]};
LowerDomain={Line[{p4,p1}//CR],Line[{pb,p4}//CR],Line[{p1,pb}//CR],Line[{p2,p3}//CR],Line[{pa,p2}//CR],Line[{p3,pa}//CR]};
Jumps={Mcs[n,t],Mcs[n,t],Pcs[n,t],Pcs[n,t],Pcs[n,t],Pcs[n,t],Mcs[n,t],Mcs[n,t],Ucs[n,t],Ucs[n,t],Lcs[n,t],Lcs[n,t],Lcs[n,t],Ucs[n,t],\[Phi]i[-1,n,t],\[CapitalDelta]\[Phi]Pi\[CapitalDelta]i[n,t],\[CapitalDelta]\[Phi]M\[CapitalDelta]i[n,t],\[CapitalDelta]\[Phi]D[n,t],\[CapitalDelta]\[Phi]LD[n,t],\[CapitalDelta]\[Phi]Ui[n,t],\[Phi]i[1,n,t],\[CapitalDelta]\[Phi]Pi\[CapitalDelta]i[n,t],\[CapitalDelta]\[Phi]M\[CapitalDelta]i[n,t],\[CapitalDelta]\[Phi]D[n,t],\[CapitalDelta]\[Phi]LD[n,t],\[CapitalDelta]\[Phi]Ui[n,t],Jcs[n,t],Jcs[n,t]};
NumPts=Join[Table[smallN,{i,1,18}],{largeN,largeN},{smallN,smallN,smallN,smallN},{largeN,largeN,smallN,smallN}];
Domain=Join[Domain,UpperDomain,LowerDomain,{Arc[0,1,{Arg[pb],Arg[pa]}]},{Arc[0,1,{-Arg[pa],-Arg[pb]}]}];
{ConjugateJumps[Jumps,DD[n,t]],Domain,NumPts}
];

CircleRHPsamp[4][n_,t_]:=Module[{Domain,NumPts,a,b,i,p1,p2,p3,p4,pa,pb,UpperDomain,UpperJumps,LowerDomain,Jumps,LowerJumps,InnerNumPts,smallrada,smallradb},
{a,b}=CSPoints[n,t];
smallradb=2Min[strip/2,Abs[a-b]/2];(*fix this scaling?*)
smallrada=Min[8smallradb,Im[a]/2];(*fix this scaling?*)
Domain=Join[RightLens[b,strip,True,smallradb],LeftLensCS[a,Min[strip,Im[a]/2],True,smallrada]];
p1=Domain[[2]][[1]]//Last;
p4=Domain[[3]][[1]]//Last;
p3=Domain[[10]][[1]]//First;
p2=Domain[[11]][[1]]//First;

pa=Exp[I (Arg[a]- ArcSin[smallrada/2]/8)];
pb=Exp[I (Arg[b]+ ArcSin[smallradb/2]/4)];

(*p2,p3 have more negative real parts*)
UpperDomain={Line[{p4,p1}],Line[{pb,p4}],Line[{p1,pb}],Line[{p2,p3}],Line[{pa,p2}],Line[{p3,pa}]};
LowerDomain={Line[{p4,p1}//CR],Line[{pb,p4}//CR],Line[{p1,pb}//CR],Line[{p2,p3}//CR],Line[{pa,p2}//CR],Line[{p3,pa}//CR]};
Jumps={Mcssamp[n,t],Mcssamp[n,t],Pcssamp[n,t],Pcssamp[n,t],Pcssamp[n,t],Pcssamp[n,t],Mcssamp[n,t],Mcssamp[n,t],Ucssamp[n,t],Ucssamp[n,t],Lcssamp[n,t],Lcssamp[n,t],Lcssamp[n,t],Ucssamp[n,t],\[Phi]isamp[-1,n,t],\[CapitalDelta]\[Phi]Pi\[CapitalDelta]isamp[n,t],\[CapitalDelta]\[Phi]M\[CapitalDelta]isamp[n,t],\[CapitalDelta]\[Phi]Dsamp[n,t],\[CapitalDelta]\[Phi]LDsamp[n,t],\[CapitalDelta]\[Phi]Uisamp[n,t],\[Phi]isamp[1,n,t],\[CapitalDelta]\[Phi]Pi\[CapitalDelta]isamp[n,t],\[CapitalDelta]\[Phi]M\[CapitalDelta]isamp[n,t],\[CapitalDelta]\[Phi]Dsamp[n,t],\[CapitalDelta]\[Phi]LDsamp[n,t],\[CapitalDelta]\[Phi]Uisamp[n,t],Jcssamp[n,t],Jcssamp[n,t]};
NumPts=Join[Table[smallN,{i,1,18}],{largeN,largeN},{smallN,smallN,smallN,smallN},{largeN,largeN,smallN,smallN}];
Domain=Join[Domain,UpperDomain,LowerDomain,{Arc[0,1,{Arg[pb],Arg[pa]}]},{Arc[0,1,{-Arg[pa],-Arg[pb]}]}];
{Jumps,Domain,NumPts}
];



CircleRHP[5][n_,t_]:=Module[{Domain,NumPts,a,b,i,p1,p4,pa,pb,UpperDomain,UpperJumps,LowerDomain,Jumps,LowerJumps,InnerNumPts,smallrada,smallradb,pam,pao,pai,Arcs},
{a,b}=TPoints[n,t];
smallradb=2Min[strip/2,Abs[a-b]/2,Im[a]/2];(*fix this scaling?*)
smallrada=Min[strip/2,Abs[a-b]/2,Im[a]/2];(*fix this scaling?*)
Domain=RightLens[b,strip,True,smallradb];
p1=Domain[[2]][[1]]//Last;
p4=Domain[[3]][[1]]//Last;

pa=Exp[I (Arg[a]- ArcSin[smallrada/2]/2)];
pam=Exp[I (Arg[a]+ ArcSin[smallrada/2]/2)];
pao=(1+smallrada/2)a;
pai=(1-smallrada/2)a;

pb=Exp[I (Arg[b]+ ArcSin[smallradb/2]/4)];

UpperDomain={Line[{p4,p1}],Line[{pb,p4}],Line[{p1,pb}],
Line[{pa,pao}],Line[{pao,pam}],Line[{pam,pai}],Line[{pai,pa}]};

LowerDomain={Line[{p4,p1}//CR],Line[{pb,p4}//CR],Line[{p1,pb}//CR],
Line[{pa,pao}//CR],Line[{pao,pam}//CR],Line[{pam,pai}//CR],Line[{pai,pa}//CR]};

Arcs={Arc[0,1,{Arg[pb],Arg[pa]}],Arc[0,1,{-Arg[pa],-Arg[pb]}],Arc[0,1,{Arg[pam],2Pi-Arg[pam]}]};
Jumps={Mt[n,t],Mt[n,t],Pt[n,t],Pt[n,t],Pt[n,t],Pt[n,t],Mt[n,t],Mt[n,t],\[Phi]ti[-1,n,t],\[Phi]iPi[n,t],\[Phi]iM[n,t],\[Phi]iM[n,t],\[Phi]iM[n,t],\[Phi]iPi[n,t],\[Phi]iPi[n,t],\[Phi]ti[-1,n,t],\[Phi]iPi[n,t],\[Phi]iM[n,t],\[Phi]iM[n,t],\[Phi]iM[n,t],\[Phi]iPi[n,t],\[Phi]iPi[n,t],Jt[n,t],Jt[n,t],Jt[n,t]};
(*Jumps={Mt[n,t],Mt[n,t],Pt[n,t],Pt[n,t],Pt[n,t],Pt[n,t],Mt[n,t],Mt[n,t],\[Phi]ti[-1,n,t],\[Phi]iPi[n,t],\[Phi]iM[n,t],\[Phi]iLD[n,t],\[Phi]iLD[n,t],\[Phi]iUi[n,t],\[Phi]iUi[n,t],\[Phi]ti[-1,n,t],\[Phi]iPi[n,t],\[Phi]iM[n,t],\[Phi]iLD[n,t],\[Phi]iLD[n,t],\[Phi]iUi[n,t],\[Phi]iUi[n,t],Jt[n,t],Jt[n,t],Jt[n,t]};*)
(*Optimize this!*)
NumPts=Table[largeN,{i,1,25}];
Domain=Join[Domain,UpperDomain,LowerDomain,Arcs];
{ConjugateJumps[Jumps,DD[n,t]],Domain,NumPts}
];

CircleRHPsamp[5][n_,t_]:=Module[{Domain,NumPts,a,b,i,p1,p4,pa,pb,UpperDomain,UpperJumps,LowerDomain,Jumps,LowerJumps,InnerNumPts,smallrada,smallradb,pam,pao,pai,Arcs},
{a,b}=TPoints[n,t];
smallradb=2Min[strip/2,Abs[a-b]/2,Im[a]/2];(*fix this scaling?*)
smallrada=Min[strip/2,Abs[a-b]/2,Im[a]/2];(*fix this scaling?*)
Domain=RightLens[b,strip,True,smallradb];
p1=Domain[[2]][[1]]//Last;
p4=Domain[[3]][[1]]//Last;

pa=Exp[I (Arg[a]- ArcSin[smallrada/2]/2)];
pam=Exp[I (Arg[a]+ ArcSin[smallrada/2]/2)];
pao=(1+smallrada/2)a;
pai=(1-smallrada/2)a;

pb=Exp[I (Arg[b]+ ArcSin[smallradb/2]/4)];

UpperDomain={Line[{p4,p1}],Line[{pb,p4}],Line[{p1,pb}],
Line[{pa,pao}],Line[{pao,pam}],Line[{pam,pai}],Line[{pai,pa}]};

LowerDomain={Line[{p4,p1}//CR],Line[{pb,p4}//CR],Line[{p1,pb}//CR],
Line[{pa,pao}//CR],Line[{pao,pam}//CR],Line[{pam,pai}//CR],Line[{pai,pa}//CR]};

Arcs={Arc[0,1,{Arg[pb],Arg[pa]}],Arc[0,1,{-Arg[pa],-Arg[pb]}],Arc[0,1,{Arg[pam],2Pi-Arg[pam]}]};

Jumps={Mtsamp[n,t],Mtsamp[n,t],Ptsamp[n,t],Ptsamp[n,t],Ptsamp[n,t],Ptsamp[n,t],Mtsamp[n,t],Mtsamp[n,t],\[Phi]tisamp[-1,n,t],\[Phi]iPisamp[n,t],\[Phi]iMsamp[n,t],\[Phi]iLDsamp[n,t],\[Phi]iLDsamp[n,t],\[Phi]iUisamp[n,t],\[Phi]iUisamp[n,t],\[Phi]tisamp[-1,n,t],\[Phi]iPisamp[n,t],\[Phi]iMsamp[n,t],\[Phi]iLDsamp[n,t],\[Phi]iLDsamp[n,t],\[Phi]iUisamp[n,t],\[Phi]iUisamp[n,t],Jtsamp[n,t],Jtsamp[n,t],Jtsamp[n,t]};
(*TODO: Optimize this?*)
NumPts=Table[largeN,{i,1,25}];
Domain=Join[Domain,UpperDomain,LowerDomain,Arcs];
{Jumps,Domain,NumPts}
];



(* give n,t,\[CapitalLambda] (eigenvalues), c (norming constants) and returns, {Jumps,Domain,Points} for the soliton circles *)
PoleList[n_,t_]:=Module[{rad,Domain,Jumps,Points,i},
rad=MinDist[{-1+strip,\[CapitalLambda],0,1-strip}//Flatten]/3;
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[\[CapitalLambda]],i++,
If[Abs[\[CapitalLambda][[i]] c[[i]] Exp[\[Theta][n,t][\[CapitalLambda][[i]]]]]>expconst,
Jumps = Join[Jumps,{S[+1][n,t,\[CapitalLambda][[i]],c[[i]]],S[+1][n,t,\[CapitalLambda][[i]],c[[i]]]}];
Jumps = Join[Jumps,{S[-1][n,t,\[CapitalLambda][[i]],c[[i]]],S[-1][n,t,\[CapitalLambda][[i]],c[[i]]]}];,
Jumps = Join[Jumps,{T[+1][n,t,\[CapitalLambda][[i]],c[[i]]],T[+1][n,t,\[CapitalLambda][[i]],c[[i]]]}];
Jumps = Join[Jumps,{T[-1][n,t,\[CapitalLambda][[i]],c[[i]]],T[-1][n,t,\[CapitalLambda][[i]],c[[i]]]}];
];
Domain= Join[Domain,Join[ContourArray[+1,rad,\[CapitalLambda][[i]]],ContourArray[-1,rad,\[CapitalLambda][[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
{ConjugateJumps[Jumps,DD[n,t]],Domain,Points}
];


(*\[Delta]cs[s_,n_,t_,R_][z_]:=\[Delta]cs[s,n,t,R][z]=\[Delta]d1[s,n,t][z(1-100s $MachineEpsilon)]*Exp[Cauchy[iftcs[\[Alpha][n,t],R],z(1-100s $MachineEpsilon)]+2 sing[\[Alpha][n,t],z(1-100s $MachineEpsilon)]](z-\[Alpha][n,t])/(z+1);*)
(*\[Phi][p_,n_,t_][z_]:=DiagonalMatrix[{Exp[g[p,n,t][z]],Exp[-g[p,n,t][z]]}];*)
DomainPlot[{}]=Null;
\[Delta]1[n_,t_,r_]:=-1/(2Pi I)(DomainIntegrate[ift[z0[n,t],r]]+2DomainIntegrate[LogFunShort[z0[n,t]]]) -1-z0[n,t]+2k\[Infinity][z0[n,t]];
\[Delta]cs1[n_,t_,r_]:=-1/(2Pi I)(DomainIntegrate[iftcs[\[Alpha][n,t],r]]+2DomainIntegrate[LogFunShort[\[Alpha][n,t]]]) -1-\[Alpha][n,t]-1/(2 Pi I)DomainIntegrate[Fun[d1[n,t]&,Arc[0,1,{Arg[\[Alpha][n,t]],2Pi-Arg[\[Alpha][n,t]]}],10]]+2k\[Infinity][\[Alpha][n,t]];
(*temp fix.  Need to figure out what's wrong with the above \[Delta]cs1*)
(*\[Delta]cs1[n_,t_,r_]:=100000(\[Delta]cs[1,n,t,r][100000]-1);*)
g1[n_,t_]:=-2I t(CauchyInverse[#,I]&/@ci[n,t]//Total);
g\[Infinity][n_,t_]:=-t(CauchyInverseIntegral[#,I]&/@ci[n,t]//Total);
\[Phi][p_,n_,t_][\[Infinity]]:=DiagonalMatrix[{Exp[g\[Infinity][n,t]],Exp[-g\[Infinity][n,t]]}];
\[Phi]i[p_,n_,t_][\[Infinity]]:=DiagonalMatrix[{Exp[-g\[Infinity][n,t]],Exp[g\[Infinity][n,t]]}];
\[Phi]1[n_,t_]:=\[Phi][1,n,t][\[Infinity]].DiagonalMatrix[{g1[n,t],-g1[n,t]}];
\[Phi]i1[n_,t_]:=\[Phi]i[1,n,t][\[Infinity]].DiagonalMatrix[{-g1[n,t],g1[n,t]}];

gt1[n_,t_]:=-2I t(CauchyInverse[#,I]&/@cit[n,t]//Total);
gt\[Infinity][n_,t_]:=-t(CauchyInverseIntegral[#,I]&/@cit[n,t]//Total);
\[Phi]t[p_,n_,t_][\[Infinity]]:=DiagonalMatrix[{Exp[gt\[Infinity][n,t]],Exp[-gt\[Infinity][n,t]]}];
\[Phi]ti[p_,n_,t_][\[Infinity]]:=DiagonalMatrix[{Exp[-gt\[Infinity][n,t]],Exp[gt\[Infinity][n,t]]}];
\[Phi]t1[n_,t_]:=\[Phi]t[1,n,t][\[Infinity]].DiagonalMatrix[{gt1[n,t],-gt1[n,t]}];
\[Phi]ti1[n_,t_]:=\[Phi]ti[1,n,t][\[Infinity]].DiagonalMatrix[{-gt1[n,t],gt1[n,t]}];


(*Better\[Delta]1[s_,n_,t_]:=-CircleNIntegrate[\[Delta][1,n,t][z],{z,0,2}]/(-2 Pi I);
Better\[Delta]i1[s_,n_,t_]:=-CircleNIntegrate[1/\[Delta][1,n,t][z],{z,0,2}]/(-2 Pi I);*)
\[CapitalDelta]1[n_,t_]:={{\[Delta]1[n,t,R], 0}, {0,-\[Delta]1[n,t,R]}};
\[CapitalDelta]cs1[n_,t_]:={{\[Delta]cs1[n,t,R], 0}, {0,-\[Delta]cs1[n,t,R]}};
mSeriesCoefficient[0]=0;
mSeriesCoefficient[1]=0;
mSeriesCoefficient[x_]:=SeriesCoefficient[x,1];
\[CapitalPhi][s_,z_,solve_]:=IdentityMatrix[2] + Cauchy[s,solve,z+s $MachineEpsilon Exp[I Arg[z]]];
\[CapitalPhi][s_,z_,{}]:=IdentityMatrix[2];
DotVect[solve_,n_,t_,i_]:=Module[{A,L,V,out,D\[Infinity],\[Phi]\[Infinity],D0,\[Phi]0},
D\[Infinity]=DD[n,t][\[Infinity]];
\[Phi]\[Infinity]=If[i==4,\[Phi][1,n,t][\[Infinity]],IdentityMatrix[2]];
(*adjust if transition region*)
If[i==5,\[Phi]\[Infinity]=\[Phi]t[1,n,t][\[Infinity]]];
D0=DD[n,t][0];
(*this should be the solution of the RHP at zero, after reversing all conjugations*)
A=D\[Infinity].\[Phi]\[Infinity].\[CapitalPhi][1,0,solve].(If[i==2,\[CapitalDelta][1,n,t][0],IdentityMatrix[2]].If[i==4,\[CapitalDelta]cs[1,n,t][0].\[Phi]i[1,n,t][0],IdentityMatrix[2]].If[i==5,\[Phi]ti[1,n,t][0],IdentityMatrix[2]]).Inverse[D0];
A=A-{{0,1},{1,0}}//Transpose;
{L,V}=Eigensystem[A,-1];
If[Abs[L[[1]]]>.00001,Print["Error estimate: "<>ToString[Abs[L[[1]]]]]];
out=V[[1]];
Exp[-I Arg[out[[1]]]]out/Sqrt[Abs[out[[1]]out[[2]]]]
];
(*overload so that null RHPs can be treated*)
RHSolve[{}]={};
DomainIntegrate[{}]=0*IdentityMatrix[2];
DomainPlot[{}]={};

ExtractSolution[i_][solved_,n_,t_]:=Module[{AA,BB,m0,m1,v,D\[Infinity],\[Phi]\[Infinity]},
v=DotVect[solved,n,t,i];
m0= v.IdentityMatrix[2];
D\[Infinity]=DD[n,t][\[Infinity]];
\[Phi]\[Infinity]=If[i==4,\[Phi][1,n,t][\[Infinity]],IdentityMatrix[2]];
(*adjust if transition region*)
If[i==5,\[Phi]\[Infinity]=\[Phi]t[1,n,t][\[Infinity]]];
m1=v.D\[Infinity].\[Phi]\[Infinity].(DomainIntegrate[solved]/(-2Pi I)+If[i==2,\[CapitalDelta]1[n,t],0]+If[i==4,\[CapitalDelta]cs1[n,t],0]).Inverse[D\[Infinity].\[Phi]\[Infinity]]+v.D\[Infinity].\[Phi]\[Infinity].Map[mSeriesCoefficient,Series[Inverse[DD[n,t][z]],{z,\[Infinity],1}],{2}].Inverse[\[Phi]\[Infinity]]+v.D\[Infinity].\[Phi]\[Infinity].If[i==4,\[Phi]i1[n,t],0IdentityMatrix[2]].Inverse[D\[Infinity]]+v.D\[Infinity].\[Phi]\[Infinity].If[i==5,\[Phi]ti1[n,t],0IdentityMatrix[2]].Inverse[D\[Infinity]];
AA= m0[[2]];
{AA,m1[[2]]/(-2 AA),m1[[1]]*(AA/2)}
];
StartToda[]:=Module[{},
TodaAB//Clear;
TodaABOld//Clear;
TodaABFlip[i_,{rrr_,lll_,ccc_}][n_,t_]:=Module[{rhp1,rhp2,rhp},
R=rrr;
c=ccc;
\[CapitalLambda]=lll;

rhp1=AdaptArcsLines[CircleRHPsamp[i][n,t],globalTol][CircleRHP[i][n,t]];
rhp2=AdaptArcsLines[PoleList[n,t],globalTol][PoleList[n,t]];
If[i==2&&rhp2!={{}},rhp2=ConjugateList[rhp2,\[CapitalDelta]i[1,n,t]]];
If[i==4&&rhp2!={{}},
rhp2=ConjugateList[rhp2,\[CapitalDelta]csi[1,n,t]];
rhp2=ConjugateList[rhp2,\[Phi][1,n,t]];
];
If[i==5&&rhp2!={{}},
rhp2=ConjugateList[rhp2,\[Phi]t[1,n,t]];
];
rhp=Join[rhp1//MakeListFun,rhp2//MakeListFun];

lastrhp=rhp;
rhp=RHSolve[rhp];
lastrhpsol=rhp;
contours=Show[Join[{Graphics[{}]},{DomainPlot[rhp]}],PlotRange->2*{{-1,1},{-1,1}},Axes->True,ImageSize->500];
innersolution[z_]:=DD[n,t][\[Infinity]].\[CapitalPhi][1,z,lastrhpsol].If[i==2,\[CapitalDelta][1,n,t][z],IdentityMatrix[2]].Inverse[DD[n,t][z]];
ExtractSolution[i][rhp,n,t]
];
TodaAB[i_][n_,t_]:=TodaAB[i][n,t]=If[n <0,TodaABFlip[i,{R2,\[CapitalLambda]2,c2}][-n,t],TodaABFlip[i,{R1,\[CapitalLambda]1,c1}][n,t]];
TodaABOld[i_][n_,t_]:=TodaABOld[i][n,t]=TodaABFlip[i,{R1,\[CapitalLambda]1,c1}][n,t];
];
StartToda[];
(*TODO: Does this work?*)
TodaChoosePos[n_,t_]:=Module[{},
If[Norm[{n,2t}]<3 ,Return[0]];(*no deformation*)
If[NZeroQ[t]|| Abs[n/t]>=1,Return[3]];(*soliton*)
If[Abs[n-t]<=1.5(t^(1/3)+1),Return[1]];(*Painleve*)
If[Abs[n/t]<=.96,Return[2]];(*dispersive*)
If[0.<=-Log[\[Rho]0[n,t]^2]/(t \[Rho]0[n,t]^3)<=.2,Return[4]];(*collisionless shock*)
(*If[-Log[\[Rho]0[n,t]^2]/.9\[LessEqual]t \[Rho]0[n,t]^3\[LessEqual] 4, Return[5]];*)(*transition, ensure TPoints gives a solution*)
Return[5];
];
TodaChoose[n_,t_]:=TodaChoosePos[Abs[n],t];
TodaABAuto[n_,t_]:=Module[{},
(*Print["Region: " <> ToString[TodaChoose[n,t]]];*)
TodaAB[TodaChoose[n,t]][n,t]];
Todaab[i_][n_,t_]:=If[n>=0,
{TodaAB[i][n,t][[1]]/TodaAB[i][n+1,t][[1]]/2,-(TodaAB[i][n,t][[2]]-TodaAB[i][n+1,t][[2]])},
{TodaAB[i][n,t][[1]]/TodaAB[i][n-1,t][[1]]/2,(TodaAB[i][n-1,t][[2]]-TodaAB[i][n-2,t][[2]])}];
TodaabAuto[n_,t_]:=If[n>=0,
{TodaABAuto[n,t][[1]]/TodaABAuto[n+1,t][[1]]/2,-(TodaABAuto[n,t][[2]]-TodaABAuto[n+1,t][[2]])},
{TodaABAuto[n,t][[1]]/TodaABAuto[n-1,t][[1]]/2,(TodaABAuto[n-1,t][[2]]-TodaABAuto[n-2,t][[2]])}];
TodaabOld[i_][n_,t_]:={TodaABOld[i][n,t][[1]]/TodaABOld[i][n+1,t][[1]]/2,-(TodaABOld[i][n,t][[2]]-TodaABOld[i][n+1,t][[2]])};



End[];
